"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(dashboard)/tutor-dashboard/page",{

/***/ "(app-pages-browser)/./src/services/tutor-dashboard.service.ts":
/*!*************************************************!*\
  !*** ./src/services/tutor-dashboard.service.ts ***!
  \*************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TutorDashboardService: function() { return /* binding */ TutorDashboardService; },\n/* harmony export */   fetchChildDetails: function() { return /* binding */ fetchChildDetails; },\n/* harmony export */   fetchSubjectDetails: function() { return /* binding */ fetchSubjectDetails; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/.pnpm/axios@1.9.0/node_modules/axios/lib/axios.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.28_@babel+core@7.27.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/build/polyfills/process.js\");\n\"use clinet\";\n\nconst API_URL = process.env.NEXT_PUBLIC_API_URL || \"http://localhost:3001\";\n// Safely check if window is defined (client-side only)\nconst isClient = \"object\" !== \"undefined\";\n// Fetches child details from the backend by ID\nconst fetchChildDetails = async (childId)=>{\n    try {\n        // Get token from localStorage - only in client environment\n        let token;\n        if (isClient) {\n            try {\n                token = localStorage.getItem(\"accessToken\");\n            } catch (e) {\n                console.error(\"Error accessing localStorage:\", e);\n                return null;\n            }\n        } else {\n            // Server-side fallback (Next.js SSR)\n            console.log(\"Running in server environment, using default token\");\n            token = \"\";\n        }\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": \"Bearer \".concat(token)\n        };\n        const response = await fetch(\"\".concat(API_URL, \"/users/children/tutoring/child/\").concat(childId), {\n            method: \"GET\",\n            headers\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            console.error(\"Error fetching child details:\", {\n                status: response.status,\n                statusText: response.statusText,\n                body: errorText\n            });\n            throw new Error(\"Error \".concat(response.status, \": \").concat(errorText));\n        }\n        const data = await response.json();\n        return data;\n    } catch (error) {\n        console.error(\"Error fetching child details for ID \".concat(childId, \":\"), error);\n        return null;\n    }\n};\n// Fetches subject details from the backend by ID\nconst fetchSubjectDetails = async (subjectId)=>{\n    try {\n        // Get token from localStorage - only in client environment\n        let token;\n        if (isClient) {\n            try {\n                token = localStorage.getItem(\"accessToken\");\n            } catch (e) {\n                console.error(\"Error accessing localStorage:\", e);\n                return null;\n            }\n        } else {\n            // Server-side fallback (Next.js SSR)\n            console.log(\"Running in server environment, using default token\");\n            token = \"\";\n        }\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": \"Bearer \".concat(token)\n        };\n        const response = await fetch(\"\".concat(API_URL, \"/subjectAndGrade/subjects/\").concat(subjectId), {\n            method: \"GET\",\n            headers\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            console.error(\"Error fetching subject details:\", {\n                status: response.status,\n                statusText: response.statusText,\n                body: errorText\n            });\n            throw new Error(\"Error \".concat(response.status, \": \").concat(errorText));\n        }\n        const data = await response.json();\n        return data;\n    } catch (error) {\n        console.error(\"Error fetching subject details for ID \".concat(subjectId, \":\"), error);\n        return null;\n    }\n};\n/**\n * TutorDashboardService\n * Handles API calls related to the tutor dashboard\n */ class TutorDashboardService {\n    /**\n   * Get authentication headers\n   * @returns Headers object with Authorization token\n   */ static getAuthHeaders() {\n        // Try multiple possible token keys to handle inconsistencies\n        let token = localStorage.getItem(\"token\") || localStorage.getItem(\"accessToken\") || sessionStorage.getItem(\"accessToken\");\n        // First, check for existing token with Bearer prefix (important!)    \n        if (token && token.startsWith(\"Bearer \")) {\n            // Token already has Bearer prefix - leave as is\n            console.log(\"Token already has Bearer prefix\");\n        } else {\n            // Check if token exists and is not malformed\n            if (!token || token === \"undefined\" || token === \"null\") {\n                console.error(\"Auth token is missing or invalid\");\n                // For now, fallback to empty token to make the error more obvious in API responses\n                token = \"\";\n            } else {\n                // Ensure token is properly trimmed to avoid whitespace issues\n                token = token.trim();\n                // Store original form for diagnostics\n                const originalTokenLength = token.length;\n                // Add Bearer prefix only if it's not already there\n                if (!token.startsWith(\"Bearer \")) {\n                    token = \"Bearer \".concat(token);\n                }\n                console.log(\"Processed token: original length=\".concat(originalTokenLength, \", new length=\").concat(token.length));\n            }\n        }\n        // Return headers with Authorization if token exists\n        return {\n            Authorization: token,\n            \"Content-Type\": \"application/json\"\n        };\n    }\n    /**\n   * Get tutor stats for dashboard\n   * @returns Promise with tutor stats\n   */ static async getTutorStats() {\n        try {\n            const headers = this.getAuthHeaders();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/users/tutors/dashboard/stats\"), {\n                headers\n            });\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching tutor stats:\", error);\n            // Return default stats if API fails\n            return {\n                rating: 0,\n                reviews: 0,\n                totalEarnings: 0,\n                monthlyEarnings: 0,\n                upcomingSessions: 0,\n                totalHours: 0,\n                completedSessions: 0,\n                subjects: []\n            };\n        }\n    }\n    /**\n   * Get upcoming sessions for the tutor\n   * @param limit Number of sessions to return\n   * @returns Promise with sessions data\n   */ static async getUpcomingSessions() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5;\n        try {\n            const headers = this.getAuthHeaders();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/tutors/sessions/my-sessions\"), {\n                headers\n            });\n            // Filter the sessions by status and limit the results on the client side\n            const upcomingSessions = response.data.filter((session)=>[\n                    \"scheduled\",\n                    \"confirmed\"\n                ].includes(session.status)).sort((a, b)=>new Date(a.startTime).getTime() - new Date(b.startTime).getTime()).slice(0, limit);\n            return upcomingSessions;\n        } catch (error) {\n            console.error(\"Error fetching upcoming sessions:\", error);\n            return [];\n        }\n    }\n    /**\n   * Get recent feedback provided by the tutor\n   * @param limit Number of feedback items to return\n   * @returns Promise with feedback data\n   */ static async getRecentFeedback() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5;\n        try {\n            const headers = this.getAuthHeaders();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/tutors/feedback/my-feedback\"), {\n                headers\n            });\n            // Process and limit the feedback data on the client side\n            const recentFeedback = response.data.sort((a, b)=>new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()).slice(0, limit);\n            return recentFeedback;\n        } catch (error) {\n            console.error(\"Error fetching recent feedback:\", error);\n            return [];\n        }\n    }\n    /**\n   * Get assignments created by the tutor\n   * @param limit Number of assignments to return\n   * @returns Promise with assignments data\n   */ static async getRecentAssignments() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5;\n        try {\n            const headers = this.getAuthHeaders();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/tutors/assignments/my-assignments\"), {\n                headers\n            });\n            // Process and limit the assignments data on the client side\n            // Sort by due date with closest due dates first\n            const recentAssignments = response.data.sort((a, b)=>new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime()).slice(0, limit);\n            return recentAssignments;\n        } catch (error) {\n            console.error(\"Error fetching recent assignments:\", error);\n            return [];\n        }\n    }\n    /**\n   * Quick assign homework to a student\n   * @param assignmentData Object containing assignment details\n   * @returns Promise with assignment creation result\n   */ static async quickAssignHomework(assignmentData) {\n        try {\n            const headers = this.getAuthHeaders();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(\"\".concat(API_URL, \"/tutors/assignments/quick-assign\"), assignmentData, {\n                headers\n            });\n            return response.data;\n        } catch (error) {\n            console.error(\"Error creating quick assignment:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Get available students for tutoring sessions\n   * @returns Promise with available students data\n   */ static async getAvailableStudents() {\n        try {\n            const headers = this.getAuthHeaders();\n            // Add cache-busting query parameter to prevent 304 responses\n            const timestamp = new Date().getTime();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/users/children/tutoring/available-students?_=\").concat(timestamp), {\n                // Add cache busting and cache prevention headers\n                params: {\n                    _: timestamp\n                },\n                headers: {\n                    ...headers,\n                    \"Cache-Control\": \"no-cache, no-store\",\n                    \"Pragma\": \"no-cache\"\n                }\n            });\n            console.log(\"Available students response:\", response.status, response.data);\n            // Return the students data directly from the API\n            return response.data || [];\n        } catch (error) {\n            console.error(\"Error fetching available students:\", error);\n            return [];\n        }\n    }\n    /**\n   * Create a new tutoring session\n   * @param sessionData The data for the new tutoring session\n   * @returns Promise with the created session data\n   */ static async createSession(sessionData) {\n        try {\n            var _headers_Authorization, _headers_Authorization1;\n            // Get token directly to ensure we're using the latest formatted version\n            const token = localStorage.getItem(\"token\") || localStorage.getItem(\"accessToken\") || sessionStorage.getItem(\"accessToken\");\n            // Format token if needed\n            const formattedToken = token && !token.startsWith(\"Bearer \") ? \"Bearer \".concat(token.trim()) : token;\n            // Use the formatted token directly\n            const headers = {\n                Authorization: formattedToken,\n                \"Content-Type\": \"application/json\"\n            };\n            console.log(\"Creating session with headers:\", {\n                authHeaderLength: ((_headers_Authorization = headers.Authorization) === null || _headers_Authorization === void 0 ? void 0 : _headers_Authorization.length) || 0,\n                hasBearerPrefix: ((_headers_Authorization1 = headers.Authorization) === null || _headers_Authorization1 === void 0 ? void 0 : _headers_Authorization1.startsWith(\"Bearer \")) || false\n            });\n            console.log(\"Creating session with data:\", {\n                ...sessionData,\n                childId: Number(sessionData.childId),\n                subjectId: Number(sessionData.subjectId)\n            });\n            // Make direct API call with the formatted header\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(\"\".concat(API_URL, \"/tutors/sessions\"), {\n                ...sessionData,\n                childId: Number(sessionData.childId),\n                subjectId: Number(sessionData.subjectId),\n                // Add durationMinutes if it doesn't exist\n                durationMinutes: sessionData.durationMinutes || (sessionData.startTime && sessionData.endTime ? Math.round((new Date(sessionData.endTime).getTime() - new Date(sessionData.startTime).getTime()) / 60000) : 60)\n            }, {\n                headers\n            });\n            console.log(\"Session created successfully:\", response.data);\n            // Store the token with Bearer prefix for future use\n            if (formattedToken) {\n                localStorage.setItem(\"token\", formattedToken);\n                localStorage.setItem(\"accessToken\", formattedToken);\n            }\n            return response.data;\n        } catch (error) {\n            console.error(\"Error creating session:\", error);\n            if (error.response) {\n                console.error(\"Error response data:\", error.response.data);\n                console.error(\"Error response status:\", error.response.status);\n            }\n            throw error;\n        }\n    }\n    /**\n   * Get completed sessions for the tutor\n   * @param limit Number of sessions to return\n   * @returns Promise with sessions data\n   */ static async getCompletedSessions() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5;\n        try {\n            const headers = this.getAuthHeaders();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/tutors/sessions/my-sessions\"), {\n                headers\n            });\n            // Filter to only include completed sessions and sort by most recent first\n            const completedSessions = response.data.filter((session)=>session.status === \"completed\").sort((a, b)=>new Date(b.endTime).getTime() - new Date(a.endTime).getTime()).slice(0, limit);\n            return completedSessions;\n        } catch (error) {\n            console.error(\"Error fetching completed sessions:\", error);\n            return [];\n        }\n    }\n    /**\n   * Calculate tutor statistics based on all available data\n   * @returns Promise with calculated statistics\n   */ static async calculateTutorStats() {\n        try {\n            // Get all sessions to calculate stats\n            const headers = this.getAuthHeaders();\n            const sessionsResponse = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/tutors/sessions/my-sessions\"), {\n                headers\n            });\n            const allSessions = sessionsResponse.data;\n            // Get tutor's profile\n            const profileResponse = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/users/tutors/profile/me\"), {\n                headers\n            });\n            const profile = profileResponse.data;\n            // Calculate stats from sessions data\n            const completedSessions = allSessions.filter((session)=>session.status === \"completed\");\n            const upcomingSessions = allSessions.filter((session)=>[\n                    \"scheduled\",\n                    \"confirmed\"\n                ].includes(session.status));\n            const totalHours = completedSessions.reduce((total, session)=>{\n                const start = new Date(session.startTime).getTime();\n                const end = new Date(session.endTime).getTime();\n                const hours = (end - start) / (1000 * 60 * 60); // Convert milliseconds to hours\n                return total + hours;\n            }, 0);\n            // Calculate monthly earnings (assuming sessions have a price field or using a default rate)\n            const currentMonth = new Date().getMonth();\n            const currentYear = new Date().getFullYear();\n            const thisMonthCompletedSessions = completedSessions.filter((session)=>{\n                const sessionDate = new Date(session.endTime);\n                return sessionDate.getMonth() === currentMonth && sessionDate.getFullYear() === currentYear;\n            });\n            // Assuming an average rate of $40/hour for calculation\n            const hourlyRate = 40;\n            const monthlyEarnings = thisMonthCompletedSessions.reduce((total, session)=>{\n                const start = new Date(session.startTime).getTime();\n                const end = new Date(session.endTime).getTime();\n                const hours = (end - start) / (1000 * 60 * 60);\n                return total + hours * hourlyRate;\n            }, 0);\n            const totalEarnings = completedSessions.reduce((total, session)=>{\n                const start = new Date(session.startTime).getTime();\n                const end = new Date(session.endTime).getTime();\n                const hours = (end - start) / (1000 * 60 * 60);\n                return total + hours * hourlyRate;\n            }, 0);\n            // Return calculated statistics\n            return {\n                rating: 4.5,\n                reviews: completedSessions.length,\n                totalEarnings: Math.round(totalEarnings),\n                monthlyEarnings: Math.round(monthlyEarnings),\n                upcomingSessions: upcomingSessions.length,\n                totalHours: Math.round(totalHours * 10) / 10,\n                completedSessions: completedSessions.length,\n                subjects: [\n                    \"Math\",\n                    \"Science\",\n                    \"English\"\n                ] // Placeholder subjects\n            };\n        } catch (error) {\n            console.error(\"Error calculating tutor stats:\", error);\n            return {\n                rating: 0,\n                reviews: 0,\n                totalEarnings: 0,\n                monthlyEarnings: 0,\n                upcomingSessions: 0,\n                totalHours: 0,\n                completedSessions: 0,\n                subjects: []\n            };\n        }\n    }\n    /**\n   * Get available students for tutoring sessions\n   * Fetches the list of students that the tutor can create sessions with\n   * @returns Promise with array of student data\n   */ static async getAvailableStudents() {\n        try {\n            const headers = this.getAuthHeaders();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/users/children/tutoring/available-students\"), {\n                headers\n            });\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching available students:\", error);\n            // Return empty array on error\n            return [];\n        }\n    }\n    /**\n   * Update a session's status\n   * @param sessionId The ID of the session to update\n   * @param status The new status to set\n   * @returns Promise with the updated session data\n   */ static async updateSessionStatus(sessionId, status) {\n        try {\n            const headers = this.getAuthHeaders();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].patch(\"\".concat(API_URL, \"/tutors/sessions/\").concat(sessionId, \"/status\"), {\n                status\n            }, {\n                headers\n            });\n            return response.data;\n        } catch (error) {\n            console.error(\"Error updating session \".concat(sessionId, \" status:\"), error);\n            throw error; // Rethrow to let the component handle the error\n        }\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy90dXRvci1kYXNoYm9hcmQuc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQzBCO0FBRTFCLE1BQU1DLFVBQVVDLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsbUJBQW1CLElBQUk7QUE4Q25ELHVEQUF1RDtBQUN2RCxNQUFNQyxXQUFXLGFBQWtCO0FBRW5DLCtDQUErQztBQUN4QyxNQUFNQyxvQkFBb0IsT0FBT0M7SUFDdEMsSUFBSTtRQUNGLDJEQUEyRDtRQUMzRCxJQUFJQztRQUNKLElBQUlILFVBQVU7WUFDWixJQUFJO2dCQUNGRyxRQUFRQyxhQUFhQyxPQUFPLENBQUM7WUFDL0IsRUFBRSxPQUFPQyxHQUFHO2dCQUNWQyxRQUFRQyxLQUFLLENBQUMsaUNBQWlDRjtnQkFDL0MsT0FBTztZQUNUO1FBQ0YsT0FBTztZQUNMLHFDQUFxQztZQUNyQ0MsUUFBUUUsR0FBRyxDQUFDO1lBQ1pOLFFBQVE7UUFDVjtRQUVBLE1BQU1PLFVBQVU7WUFDZCxnQkFBZ0I7WUFDaEIsaUJBQWlCLFVBQWdCLE9BQU5QO1FBQzdCO1FBRUEsTUFBTVEsV0FBVyxNQUFNQyxNQUFNLEdBQTRDVixPQUF6Q04sU0FBUSxtQ0FBeUMsT0FBUk0sVUFBVztZQUNsRlcsUUFBUTtZQUNSSDtRQUNGO1FBRUEsSUFBSSxDQUFDQyxTQUFTRyxFQUFFLEVBQUU7WUFDaEIsTUFBTUMsWUFBWSxNQUFNSixTQUFTSyxJQUFJO1lBQ3JDVCxRQUFRQyxLQUFLLENBQUUsaUNBQWdDO2dCQUM3Q1MsUUFBUU4sU0FBU00sTUFBTTtnQkFDdkJDLFlBQVlQLFNBQVNPLFVBQVU7Z0JBQy9CQyxNQUFNSjtZQUNSO1lBQ0EsTUFBTSxJQUFJSyxNQUFNLFNBQTZCTCxPQUFwQkosU0FBU00sTUFBTSxFQUFDLE1BQWMsT0FBVkY7UUFDL0M7UUFFQSxNQUFNTSxPQUFPLE1BQU1WLFNBQVNXLElBQUk7UUFDaEMsT0FBT0Q7SUFDVCxFQUFFLE9B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O1FBQ0Y7SUFDRjtJQUVBOzs7O0dBSUMsR0FDRCxhQUFhc0IsdUJBQTJDO1FBQ3RELElBQUk7WUFDRixNQUFNdEQsVUFBVSxJQUFJLENBQUNnQixjQUFjO1lBQ25DLE1BQU1mLFdBQVcsTUFBTWhCLDZDQUFLQSxDQUFDdUMsR0FBRyxDQUFDLEdBQVcsT0FBUnRDLFNBQVEsZ0RBQThDO2dCQUFFYztZQUFRO1lBQ3BHLE9BQU9DLFNBQVNVLElBQUk7UUFDdEIsRUFBRSxPQUFPYixPQUFPO1lBQ2RELFFBQVFDLEtBQUssQ0FBQyxzQ0FBc0NBO1lBQ3BELDhCQUE4QjtZQUM5QixPQUFPLEVBQUU7UUFDWDtJQUNGO0lBRUE7Ozs7O0dBS0MsR0FDRCxhQUFheUYsb0JBQW9CQyxTQUFpQixFQUFFakYsTUFBYyxFQUE0QjtRQUM1RixJQUFJO1lBQ0YsTUFBTVAsVUFBVSxJQUFJLENBQUNnQixjQUFjO1lBQ25DLE1BQU1mLFdBQVcsTUFBTWhCLDZDQUFLQSxDQUFDd0csS0FBSyxDQUNoQyxHQUE4QkQsT0FBM0J0RyxTQUFRLHFCQUE2QixPQUFWc0csV0FBVSxZQUN4QztnQkFBRWpGO1lBQU8sR0FDVDtnQkFBRVA7WUFBUTtZQUdaLE9BQU9DLFNBQVNVLElBQUk7UUFDdEIsRUFBRSxPQUFPYixPQUFPO1lBQ2RELFFBQVFDLEtBQUssQ0FBQywwQkFBb0MsT0FBVjBGLFdBQVUsYUFBVzFGO1lBQzdELE1BQU1BLE9BQU8sZ0RBQWdEO1FBQy9EO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc2VydmljZXMvdHV0b3ItZGFzaGJvYXJkLnNlcnZpY2UudHM/YWY5NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaW5ldCdcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5cbmNvbnN0IEFQSV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjMwMDEnO1xuXG4vLyBJbnRlcmZhY2UgZGVmaW5pdGlvbnMgZm9yIHR1dG9yIGRhc2hib2FyZCBkYXRhXG5leHBvcnQgaW50ZXJmYWNlIFR1dG9yU3RhdHMge1xuICByYXRpbmc6IG51bWJlcjtcbiAgcmV2aWV3czogbnVtYmVyO1xuICB0b3RhbEVhcm5pbmdzOiBudW1iZXI7XG4gIG1vbnRobHlFYXJuaW5nczogbnVtYmVyO1xuICB1cGNvbWluZ1Nlc3Npb25zOiBudW1iZXI7XG4gIHRvdGFsSG91cnM6IG51bWJlcjtcbiAgY29tcGxldGVkU2Vzc2lvbnM6IG51bWJlcjtcbiAgc3ViamVjdHM6IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFR1dG9yaW5nU2Vzc2lvbiB7XG4gIGlkPzogbnVtYmVyOyAvLyBOZXcgcHJpbWFyeSBrZXkgZnJvbSBiYWNrZW5kXG4gIHNlc3Npb25JZD86IG51bWJlcjsgLy8gS2VlcCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICBjaGlsZElkOiBudW1iZXI7XG4gIGNoaWxkTmFtZT86IHN0cmluZztcbiAgc3ViamVjdElkOiBudW1iZXI7XG4gIHN1YmplY3Q/OiBzdHJpbmc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIHN0YXJ0VGltZTogc3RyaW5nO1xuICBlbmRUaW1lOiBzdHJpbmc7XG4gIHN0YXR1czogJ3NjaGVkdWxlZCcgfCAnY29uZmlybWVkJyB8ICdjb21wbGV0ZWQnIHwgJ2NhbmNlbGxlZCcgfCAnaW5fcHJvZ3Jlc3MnO1xuICBub3Rlcz86IHN0cmluZztcbiAgZHVyYXRpb25NaW51dGVzPzogbnVtYmVyO1xuICBncmFkZUxldmVsTmFtZT86IHN0cmluZzsgLy8gQWRkZWQgdG8gbWF0Y2ggdGhlIHVzYWdlIGluIHRoZSBVSVxufVxuXG4vLyBDaGlsZCBhbmQgc3ViamVjdCBpbmZvcm1hdGlvbiBpbnRlcmZhY2VzXG4vLyBUaGVzZSBhcmUgZm9yIEFQSSByZXNwb25zZXMgZnJvbSB0aGUgZGF0YWJhc2VcbmV4cG9ydCBpbnRlcmZhY2UgQ2hpbGREZXRhaWxzIHtcbiAgY2hpbGRJZDogbnVtYmVyO1xuICBmaXJzdE5hbWU6IHN0cmluZztcbiAgbGFzdE5hbWU6IHN0cmluZztcbiAgZnVsbE5hbWU6IHN0cmluZztcbiAgZ3JhZGVMZXZlbElkPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN1YmplY3REZXRhaWxzIHtcbiAgc3ViamVjdElkOiBudW1iZXI7XG4gIG5hbWU6IHN0cmluZztcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG59XG5cbi8vIFNhZmVseSBjaGVjayBpZiB3aW5kb3cgaXMgZGVmaW5lZCAoY2xpZW50LXNpZGUgb25seSlcbmNvbnN0IGlzQ2xpZW50ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8vIEZldGNoZXMgY2hpbGQgZGV0YWlscyBmcm9tIHRoZSBiYWNrZW5kIGJ5IElEXG5leHBvcnQgY29uc3QgZmV0Y2hDaGlsZERldGFpbHMgPSBhc3luYyAoY2hpbGRJZDogbnVtYmVyKTogUHJvbWlzZTxDaGlsZERldGFpbHMgfCBudWxsPiA9PiB7XG4gIHRyeSB7XG4gICAgLy8gR2V0IHRva2VuIGZyb20gbG9jYWxTdG9yYWdlIC0gb25seSBpbiBjbGllbnQgZW52aXJvbm1lbnRcbiAgICBsZXQgdG9rZW47XG4gICAgaWYgKGlzQ2xpZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhY2Nlc3NUb2tlbicpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhY2Nlc3NpbmcgbG9jYWxTdG9yYWdlOicsIGUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2VydmVyLXNpZGUgZmFsbGJhY2sgKE5leHQuanMgU1NSKVxuICAgICAgY29uc29sZS5sb2coJ1J1bm5pbmcgaW4gc2VydmVyIGVudmlyb25tZW50LCB1c2luZyBkZWZhdWx0IHRva2VuJyk7XG4gICAgICB0b2tlbiA9ICcnO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWBcbiAgICB9O1xuICAgIFxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX1VSTH0vdXNlcnMvY2hpbGRyZW4vdHV0b3JpbmcvY2hpbGQvJHtjaGlsZElkfWAsIHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBoZWFkZXJzXG4gICAgfSk7XG4gICAgXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgY2hpbGQgZGV0YWlsczpgLCB7XG4gICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICBib2R5OiBlcnJvclRleHRcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciAke3Jlc3BvbnNlLnN0YXR1c306ICR7ZXJyb3JUZXh0fWApO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIHJldHVybiBkYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGNoaWxkIGRldGFpbHMgZm9yIElEICR7Y2hpbGRJZH06YCwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vLyBGZXRjaGVzIHN1YmplY3QgZGV0YWlscyBmcm9tIHRoZSBiYWNrZW5kIGJ5IElEXG5leHBvcnQgY29uc3QgZmV0Y2hTdWJqZWN0RGV0YWlscyA9IGFzeW5jIChzdWJqZWN0SWQ6IG51bWJlcik6IFByb21pc2U8U3ViamVjdERldGFpbHMgfCBudWxsPiA9PiB7XG4gIHRyeSB7XG4gICAgLy8gR2V0IHRva2VuIGZyb20gbG9jYWxTdG9yYWdlIC0gb25seSBpbiBjbGllbnQgZW52aXJvbm1lbnRcbiAgICBsZXQgdG9rZW47XG4gICAgaWYgKGlzQ2xpZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhY2Nlc3NUb2tlbicpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhY2Nlc3NpbmcgbG9jYWxTdG9yYWdlOicsIGUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2VydmVyLXNpZGUgZmFsbGJhY2sgKE5leHQuanMgU1NSKVxuICAgICAgY29uc29sZS5sb2coJ1J1bm5pbmcgaW4gc2VydmVyIGVudmlyb25tZW50LCB1c2luZyBkZWZhdWx0IHRva2VuJyk7XG4gICAgICB0b2tlbiA9ICcnO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWBcbiAgICB9O1xuICAgIFxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX1VSTH0vc3ViamVjdEFuZEdyYWRlL3N1YmplY3RzLyR7c3ViamVjdElkfWAsIHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBoZWFkZXJzXG4gICAgfSk7XG4gICAgXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgc3ViamVjdCBkZXRhaWxzOmAsIHtcbiAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgIGJvZHk6IGVycm9yVGV4dFxuICAgICAgfSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtlcnJvclRleHR9YCk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgc3ViamVjdCBkZXRhaWxzIGZvciBJRCAke3N1YmplY3RJZH06YCwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXNzaWdubWVudCB7XG4gIGFzc2lnbm1lbnRJZDogbnVtYmVyO1xuICBjaGlsZElkOiBudW1iZXI7XG4gIGNoaWxkTmFtZT86IHN0cmluZztcbiAgdGl0bGU6IHN0cmluZztcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgZHVlRGF0ZTogc3RyaW5nO1xuICBzdGF0dXM6ICdwZW5kaW5nJyB8ICdzdWJtaXR0ZWQnIHwgJ2dyYWRlZCcgfCAnbGF0ZSc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmVlZGJhY2sge1xuICBmZWVkYmFja0lkOiBudW1iZXI7XG4gIGNoaWxkSWQ6IG51bWJlcjtcbiAgY2hpbGROYW1lPzogc3RyaW5nO1xuICB0aXRsZTogc3RyaW5nO1xuICBjb250ZW50OiBzdHJpbmc7XG4gIGZlZWRiYWNrVHlwZTogc3RyaW5nO1xuICBjcmVhdGVkQXQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdHVkZW50IHtcbiAgY2hpbGRJZDogbnVtYmVyO1xuICBmaXJzdE5hbWU6IHN0cmluZztcbiAgbGFzdE5hbWU6IHN0cmluZztcbiAgdXNlcm5hbWU6IHN0cmluZztcbiAgcGhvdG86IHN0cmluZyB8IG51bGw7XG4gIGdyYWRlTGV2ZWxJZDogbnVtYmVyIHwgbnVsbDtcbiAgZ3JhZGVMZXZlbE5hbWU6IHN0cmluZztcbiAgc3ViamVjdHM6IHN0cmluZ1tdO1xufVxuXG4vKipcbiAqIFR1dG9yRGFzaGJvYXJkU2VydmljZVxuICogSGFuZGxlcyBBUEkgY2FsbHMgcmVsYXRlZCB0byB0aGUgdHV0b3IgZGFzaGJvYXJkXG4gKi9cbmV4cG9ydCBjbGFzcyBUdXRvckRhc2hib2FyZFNlcnZpY2Uge1xuICAvKipcbiAgICogR2V0IGF1dGhlbnRpY2F0aW9uIGhlYWRlcnNcbiAgICogQHJldHVybnMgSGVhZGVycyBvYmplY3Qgd2l0aCBBdXRob3JpemF0aW9uIHRva2VuXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBnZXRBdXRoSGVhZGVycygpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgICAvLyBUcnkgbXVsdGlwbGUgcG9zc2libGUgdG9rZW4ga2V5cyB0byBoYW5kbGUgaW5jb25zaXN0ZW5jaWVzXG4gICAgbGV0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3Rva2VuJykgfHwgXG4gICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYWNjZXNzVG9rZW4nKSB8fCBcbiAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ2FjY2Vzc1Rva2VuJyk7XG4gICAgXG4gICAgLy8gRmlyc3QsIGNoZWNrIGZvciBleGlzdGluZyB0b2tlbiB3aXRoIEJlYXJlciBwcmVmaXggKGltcG9ydGFudCEpICAgIFxuICAgIGlmICh0b2tlbiAmJiB0b2tlbi5zdGFydHNXaXRoKCdCZWFyZXIgJykpIHtcbiAgICAgIC8vIFRva2VuIGFscmVhZHkgaGFzIEJlYXJlciBwcmVmaXggLSBsZWF2ZSBhcyBpc1xuICAgICAgY29uc29sZS5sb2coJ1Rva2VuIGFscmVhZHkgaGFzIEJlYXJlciBwcmVmaXgnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2hlY2sgaWYgdG9rZW4gZXhpc3RzIGFuZCBpcyBub3QgbWFsZm9ybWVkXG4gICAgICBpZiAoIXRva2VuIHx8IHRva2VuID09PSAndW5kZWZpbmVkJyB8fCB0b2tlbiA9PT0gJ251bGwnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F1dGggdG9rZW4gaXMgbWlzc2luZyBvciBpbnZhbGlkJyk7XG4gICAgICAgIC8vIEZvciBub3csIGZhbGxiYWNrIHRvIGVtcHR5IHRva2VuIHRvIG1ha2UgdGhlIGVycm9yIG1vcmUgb2J2aW91cyBpbiBBUEkgcmVzcG9uc2VzXG4gICAgICAgIHRva2VuID0gJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFbnN1cmUgdG9rZW4gaXMgcHJvcGVybHkgdHJpbW1lZCB0byBhdm9pZCB3aGl0ZXNwYWNlIGlzc3Vlc1xuICAgICAgICB0b2tlbiA9IHRva2VuLnRyaW0oKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0b3JlIG9yaWdpbmFsIGZvcm0gZm9yIGRpYWdub3N0aWNzXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsVG9rZW5MZW5ndGggPSB0b2tlbi5sZW5ndGg7XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgQmVhcmVyIHByZWZpeCBvbmx5IGlmIGl0J3Mgbm90IGFscmVhZHkgdGhlcmVcbiAgICAgICAgaWYgKCF0b2tlbi5zdGFydHNXaXRoKCdCZWFyZXIgJykpIHtcbiAgICAgICAgICB0b2tlbiA9IGBCZWFyZXIgJHt0b2tlbn1gO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgUHJvY2Vzc2VkIHRva2VuOiBvcmlnaW5hbCBsZW5ndGg9JHtvcmlnaW5hbFRva2VuTGVuZ3RofSwgbmV3IGxlbmd0aD0ke3Rva2VuLmxlbmd0aH1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gUmV0dXJuIGhlYWRlcnMgd2l0aCBBdXRob3JpemF0aW9uIGlmIHRva2VuIGV4aXN0c1xuICAgIHJldHVybiB7XG4gICAgICBBdXRob3JpemF0aW9uOiB0b2tlbiwgLy8gRG9uJ3QgYWRkIEJlYXJlciBwcmVmaXggYWdhaW4gLSBpdCBzaG91bGQgYWxyZWFkeSBiZSBpbiB0aGUgdG9rZW5cbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0dXRvciBzdGF0cyBmb3IgZGFzaGJvYXJkXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCB0dXRvciBzdGF0c1xuICAgKi9cbiAgc3RhdGljIGFzeW5jIGdldFR1dG9yU3RhdHMoKTogUHJvbWlzZTxUdXRvclN0YXRzPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmdldEF1dGhIZWFkZXJzKCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChcbiAgICAgICAgYCR7QVBJX1VSTH0vdXNlcnMvdHV0b3JzL2Rhc2hib2FyZC9zdGF0c2AsXG4gICAgICAgIHsgaGVhZGVycyB9XG4gICAgICApO1xuICAgICAgXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgdHV0b3Igc3RhdHM6JywgZXJyb3IpO1xuICAgICAgLy8gUmV0dXJuIGRlZmF1bHQgc3RhdHMgaWYgQVBJIGZhaWxzXG4gICAgICByZXR1cm4ge1xuICAgICAgICByYXRpbmc6IDAsXG4gICAgICAgIHJldmlld3M6IDAsXG4gICAgICAgIHRvdGFsRWFybmluZ3M6IDAsXG4gICAgICAgIG1vbnRobHlFYXJuaW5nczogMCxcbiAgICAgICAgdXBjb21pbmdTZXNzaW9uczogMCxcbiAgICAgICAgdG90YWxIb3VyczogMCxcbiAgICAgICAgY29tcGxldGVkU2Vzc2lvbnM6IDAsXG4gICAgICAgIHN1YmplY3RzOiBbXVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHVwY29taW5nIHNlc3Npb25zIGZvciB0aGUgdHV0b3JcbiAgICogQHBhcmFtIGxpbWl0IE51bWJlciBvZiBzZXNzaW9ucyB0byByZXR1cm5cbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHNlc3Npb25zIGRhdGFcbiAgICovXG4gIHN0YXRpYyBhc3luYyBnZXRVcGNvbWluZ1Nlc3Npb25zKGxpbWl0ID0gNSk6IFByb21pc2U8VHV0b3JpbmdTZXNzaW9uW10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuZ2V0QXV0aEhlYWRlcnMoKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KFxuICAgICAgICBgJHtBUElfVVJMfS90dXRvcnMvc2Vzc2lvbnMvbXktc2Vzc2lvbnNgLFxuICAgICAgICB7IGhlYWRlcnMgfVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gRmlsdGVyIHRoZSBzZXNzaW9ucyBieSBzdGF0dXMgYW5kIGxpbWl0IHRoZSByZXN1bHRzIG9uIHRoZSBjbGllbnQgc2lkZVxuICAgICAgY29uc3QgdXBjb21pbmdTZXNzaW9ucyA9IHJlc3BvbnNlLmRhdGFcbiAgICAgICAgLmZpbHRlcigoc2Vzc2lvbjogVHV0b3JpbmdTZXNzaW9uKSA9PiBbJ3NjaGVkdWxlZCcsICdjb25maXJtZWQnXS5pbmNsdWRlcyhzZXNzaW9uLnN0YXR1cykpXG4gICAgICAgIC5zb3J0KChhOiBUdXRvcmluZ1Nlc3Npb24sIGI6IFR1dG9yaW5nU2Vzc2lvbikgPT4gbmV3IERhdGUoYS5zdGFydFRpbWUpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGIuc3RhcnRUaW1lKS5nZXRUaW1lKCkpXG4gICAgICAgIC5zbGljZSgwLCBsaW1pdCk7XG4gICAgICBcbiAgICAgIHJldHVybiB1cGNvbWluZ1Nlc3Npb25zO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB1cGNvbWluZyBzZXNzaW9uczonLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCByZWNlbnQgZmVlZGJhY2sgcHJvdmlkZWQgYnkgdGhlIHR1dG9yXG4gICAqIEBwYXJhbSBsaW1pdCBOdW1iZXIgb2YgZmVlZGJhY2sgaXRlbXMgdG8gcmV0dXJuXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBmZWVkYmFjayBkYXRhXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZ2V0UmVjZW50RmVlZGJhY2sobGltaXQgPSA1KTogUHJvbWlzZTxGZWVkYmFja1tdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmdldEF1dGhIZWFkZXJzKCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChcbiAgICAgICAgYCR7QVBJX1VSTH0vdHV0b3JzL2ZlZWRiYWNrL215LWZlZWRiYWNrYCxcbiAgICAgICAgeyBoZWFkZXJzIH1cbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIFByb2Nlc3MgYW5kIGxpbWl0IHRoZSBmZWVkYmFjayBkYXRhIG9uIHRoZSBjbGllbnQgc2lkZVxuICAgICAgY29uc3QgcmVjZW50RmVlZGJhY2sgPSByZXNwb25zZS5kYXRhXG4gICAgICAgIC5zb3J0KChhOiBGZWVkYmFjaywgYjogRmVlZGJhY2spID0+IG5ldyBEYXRlKGIuY3JlYXRlZEF0KS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShhLmNyZWF0ZWRBdCkuZ2V0VGltZSgpKVxuICAgICAgICAuc2xpY2UoMCwgbGltaXQpO1xuICAgICAgXG4gICAgICByZXR1cm4gcmVjZW50RmVlZGJhY2s7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHJlY2VudCBmZWVkYmFjazonLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhc3NpZ25tZW50cyBjcmVhdGVkIGJ5IHRoZSB0dXRvclxuICAgKiBAcGFyYW0gbGltaXQgTnVtYmVyIG9mIGFzc2lnbm1lbnRzIHRvIHJldHVyblxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggYXNzaWdubWVudHMgZGF0YVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGdldFJlY2VudEFzc2lnbm1lbnRzKGxpbWl0ID0gNSk6IFByb21pc2U8QXNzaWdubWVudFtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmdldEF1dGhIZWFkZXJzKCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChcbiAgICAgICAgYCR7QVBJX1VSTH0vdHV0b3JzL2Fzc2lnbm1lbnRzL215LWFzc2lnbm1lbnRzYCxcbiAgICAgICAgeyBoZWFkZXJzIH1cbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIFByb2Nlc3MgYW5kIGxpbWl0IHRoZSBhc3NpZ25tZW50cyBkYXRhIG9uIHRoZSBjbGllbnQgc2lkZVxuICAgICAgLy8gU29ydCBieSBkdWUgZGF0ZSB3aXRoIGNsb3Nlc3QgZHVlIGRhdGVzIGZpcnN0XG4gICAgICBjb25zdCByZWNlbnRBc3NpZ25tZW50cyA9IHJlc3BvbnNlLmRhdGFcbiAgICAgICAgLnNvcnQoKGE6IEFzc2lnbm1lbnQsIGI6IEFzc2lnbm1lbnQpID0+IG5ldyBEYXRlKGEuZHVlRGF0ZSkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYi5kdWVEYXRlKS5nZXRUaW1lKCkpXG4gICAgICAgIC5zbGljZSgwLCBsaW1pdCk7XG4gICAgICBcbiAgICAgIHJldHVybiByZWNlbnRBc3NpZ25tZW50cztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcmVjZW50IGFzc2lnbm1lbnRzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUXVpY2sgYXNzaWduIGhvbWV3b3JrIHRvIGEgc3R1ZGVudFxuICAgKiBAcGFyYW0gYXNzaWdubWVudERhdGEgT2JqZWN0IGNvbnRhaW5pbmcgYXNzaWdubWVudCBkZXRhaWxzXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBhc3NpZ25tZW50IGNyZWF0aW9uIHJlc3VsdFxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHF1aWNrQXNzaWduSG9tZXdvcmsoYXNzaWdubWVudERhdGE6IHtcbiAgICBjaGlsZElkOiBudW1iZXI7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICAgIHN1YmplY3RJZDogbnVtYmVyO1xuICAgIGR1ZURhdGU6IHN0cmluZztcbiAgICBub3Rlcz86IHN0cmluZztcbiAgfSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5nZXRBdXRoSGVhZGVycygpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5wb3N0KFxuICAgICAgICBgJHtBUElfVVJMfS90dXRvcnMvYXNzaWdubWVudHMvcXVpY2stYXNzaWduYCxcbiAgICAgICAgYXNzaWdubWVudERhdGEsXG4gICAgICAgIHsgaGVhZGVycyB9XG4gICAgICApO1xuICAgICAgXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgcXVpY2sgYXNzaWdubWVudDonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGF2YWlsYWJsZSBzdHVkZW50cyBmb3IgdHV0b3Jpbmcgc2Vzc2lvbnNcbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIGF2YWlsYWJsZSBzdHVkZW50cyBkYXRhXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZ2V0QXZhaWxhYmxlU3R1ZGVudHMoKTogUHJvbWlzZTxTdHVkZW50W10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuZ2V0QXV0aEhlYWRlcnMoKTtcbiAgICAgIFxuICAgICAgLy8gQWRkIGNhY2hlLWJ1c3RpbmcgcXVlcnkgcGFyYW1ldGVyIHRvIHByZXZlbnQgMzA0IHJlc3BvbnNlc1xuICAgICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChcbiAgICAgICAgYCR7QVBJX1VSTH0vdXNlcnMvY2hpbGRyZW4vdHV0b3JpbmcvYXZhaWxhYmxlLXN0dWRlbnRzP189JHt0aW1lc3RhbXB9YCxcbiAgICAgICAgeyBcbiAgICAgICAgICAvLyBBZGQgY2FjaGUgYnVzdGluZyBhbmQgY2FjaGUgcHJldmVudGlvbiBoZWFkZXJzXG4gICAgICAgICAgcGFyYW1zOiB7IF86IHRpbWVzdGFtcCB9LFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIC4uLmhlYWRlcnMsXG4gICAgICAgICAgICAnQ2FjaGUtQ29udHJvbCc6ICduby1jYWNoZSwgbm8tc3RvcmUnLFxuICAgICAgICAgICAgJ1ByYWdtYSc6ICduby1jYWNoZSdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdBdmFpbGFibGUgc3R1ZGVudHMgcmVzcG9uc2U6JywgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS5kYXRhKTtcbiAgICAgIFxuICAgICAgLy8gUmV0dXJuIHRoZSBzdHVkZW50cyBkYXRhIGRpcmVjdGx5IGZyb20gdGhlIEFQSVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEgfHwgW107XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGF2YWlsYWJsZSBzdHVkZW50czonLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyB0dXRvcmluZyBzZXNzaW9uXG4gICAqIEBwYXJhbSBzZXNzaW9uRGF0YSBUaGUgZGF0YSBmb3IgdGhlIG5ldyB0dXRvcmluZyBzZXNzaW9uXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCB0aGUgY3JlYXRlZCBzZXNzaW9uIGRhdGFcbiAgICovXG4gIHN0YXRpYyBhc3luYyBjcmVhdGVTZXNzaW9uKHNlc3Npb25EYXRhOiBhbnkpOiBQcm9taXNlPGFueT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgdG9rZW4gZGlyZWN0bHkgdG8gZW5zdXJlIHdlJ3JlIHVzaW5nIHRoZSBsYXRlc3QgZm9ybWF0dGVkIHZlcnNpb25cbiAgICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3Rva2VuJykgfHwgXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhY2Nlc3NUb2tlbicpIHx8IFxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCdhY2Nlc3NUb2tlbicpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgIC8vIEZvcm1hdCB0b2tlbiBpZiBuZWVkZWRcbiAgICAgIGNvbnN0IGZvcm1hdHRlZFRva2VuID0gdG9rZW4gJiYgIXRva2VuLnN0YXJ0c1dpdGgoJ0JlYXJlciAnKSA/IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYEJlYXJlciAke3Rva2VuLnRyaW0oKX1gIDogdG9rZW47XG4gICAgICBcbiAgICAgIC8vIFVzZSB0aGUgZm9ybWF0dGVkIHRva2VuIGRpcmVjdGx5XG4gICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICBBdXRob3JpemF0aW9uOiBmb3JtYXR0ZWRUb2tlbixcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIHNlc3Npb24gd2l0aCBoZWFkZXJzOicsIHtcbiAgICAgICAgYXV0aEhlYWRlckxlbmd0aDogaGVhZGVycy5BdXRob3JpemF0aW9uPy5sZW5ndGggfHwgMCxcbiAgICAgICAgaGFzQmVhcmVyUHJlZml4OiBoZWFkZXJzLkF1dGhvcml6YXRpb24/LnN0YXJ0c1dpdGgoJ0JlYXJlciAnKSB8fCBmYWxzZVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdDcmVhdGluZyBzZXNzaW9uIHdpdGggZGF0YTonLCB7XG4gICAgICAgIC4uLnNlc3Npb25EYXRhLFxuICAgICAgICBjaGlsZElkOiBOdW1iZXIoc2Vzc2lvbkRhdGEuY2hpbGRJZCksXG4gICAgICAgIHN1YmplY3RJZDogTnVtYmVyKHNlc3Npb25EYXRhLnN1YmplY3RJZCkgIFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIE1ha2UgZGlyZWN0IEFQSSBjYWxsIHdpdGggdGhlIGZvcm1hdHRlZCBoZWFkZXJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MucG9zdChcbiAgICAgICAgYCR7QVBJX1VSTH0vdHV0b3JzL3Nlc3Npb25zYCxcbiAgICAgICAge1xuICAgICAgICAgIC4uLnNlc3Npb25EYXRhLFxuICAgICAgICAgIGNoaWxkSWQ6IE51bWJlcihzZXNzaW9uRGF0YS5jaGlsZElkKSxcbiAgICAgICAgICBzdWJqZWN0SWQ6IE51bWJlcihzZXNzaW9uRGF0YS5zdWJqZWN0SWQpLFxuICAgICAgICAgIC8vIEFkZCBkdXJhdGlvbk1pbnV0ZXMgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgICAgICAgIGR1cmF0aW9uTWludXRlczogc2Vzc2lvbkRhdGEuZHVyYXRpb25NaW51dGVzIHx8IFxuICAgICAgICAgICAgKHNlc3Npb25EYXRhLnN0YXJ0VGltZSAmJiBzZXNzaW9uRGF0YS5lbmRUaW1lID8gXG4gICAgICAgICAgICBNYXRoLnJvdW5kKChuZXcgRGF0ZShzZXNzaW9uRGF0YS5lbmRUaW1lKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShzZXNzaW9uRGF0YS5zdGFydFRpbWUpLmdldFRpbWUoKSkgLyA2MDAwMCkgOiA2MClcbiAgICAgICAgfSxcbiAgICAgICAgeyBoZWFkZXJzIH1cbiAgICAgICk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdTZXNzaW9uIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5OicsIHJlc3BvbnNlLmRhdGEpO1xuICAgICAgXG4gICAgICAvLyBTdG9yZSB0aGUgdG9rZW4gd2l0aCBCZWFyZXIgcHJlZml4IGZvciBmdXR1cmUgdXNlXG4gICAgICBpZiAoZm9ybWF0dGVkVG9rZW4pIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3Rva2VuJywgZm9ybWF0dGVkVG9rZW4pO1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnYWNjZXNzVG9rZW4nLCBmb3JtYXR0ZWRUb2tlbik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHNlc3Npb246JywgZXJyb3IpO1xuICAgICAgaWYgKGVycm9yLnJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlc3BvbnNlIGRhdGE6JywgZXJyb3IucmVzcG9uc2UuZGF0YSk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlc3BvbnNlIHN0YXR1czonLCBlcnJvci5yZXNwb25zZS5zdGF0dXMpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjb21wbGV0ZWQgc2Vzc2lvbnMgZm9yIHRoZSB0dXRvclxuICAgKiBAcGFyYW0gbGltaXQgTnVtYmVyIG9mIHNlc3Npb25zIHRvIHJldHVyblxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggc2Vzc2lvbnMgZGF0YVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGdldENvbXBsZXRlZFNlc3Npb25zKGxpbWl0ID0gNSk6IFByb21pc2U8VHV0b3JpbmdTZXNzaW9uW10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuZ2V0QXV0aEhlYWRlcnMoKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KFxuICAgICAgICBgJHtBUElfVVJMfS90dXRvcnMvc2Vzc2lvbnMvbXktc2Vzc2lvbnNgLFxuICAgICAgICB7IGhlYWRlcnMgfVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gRmlsdGVyIHRvIG9ubHkgaW5jbHVkZSBjb21wbGV0ZWQgc2Vzc2lvbnMgYW5kIHNvcnQgYnkgbW9zdCByZWNlbnQgZmlyc3RcbiAgICAgIGNvbnN0IGNvbXBsZXRlZFNlc3Npb25zID0gcmVzcG9uc2UuZGF0YVxuICAgICAgICAuZmlsdGVyKChzZXNzaW9uOiBUdXRvcmluZ1Nlc3Npb24pID0+IHNlc3Npb24uc3RhdHVzID09PSAnY29tcGxldGVkJylcbiAgICAgICAgLnNvcnQoKGE6IFR1dG9yaW5nU2Vzc2lvbiwgYjogVHV0b3JpbmdTZXNzaW9uKSA9PiBuZXcgRGF0ZShiLmVuZFRpbWUpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGEuZW5kVGltZSkuZ2V0VGltZSgpKVxuICAgICAgICAuc2xpY2UoMCwgbGltaXQpO1xuICAgICAgXG4gICAgICByZXR1cm4gY29tcGxldGVkU2Vzc2lvbnM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGNvbXBsZXRlZCBzZXNzaW9uczonLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0dXRvciBzdGF0aXN0aWNzIGJhc2VkIG9uIGFsbCBhdmFpbGFibGUgZGF0YVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggY2FsY3VsYXRlZCBzdGF0aXN0aWNzXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgY2FsY3VsYXRlVHV0b3JTdGF0cygpOiBQcm9taXNlPFR1dG9yU3RhdHM+IHtcbiAgICB0cnkge1xuICAgICAgLy8gR2V0IGFsbCBzZXNzaW9ucyB0byBjYWxjdWxhdGUgc3RhdHNcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmdldEF1dGhIZWFkZXJzKCk7XG4gICAgICBjb25zdCBzZXNzaW9uc1Jlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KGAke0FQSV9VUkx9L3R1dG9ycy9zZXNzaW9ucy9teS1zZXNzaW9uc2AsIHsgaGVhZGVycyB9KTtcbiAgICAgIGNvbnN0IGFsbFNlc3Npb25zID0gc2Vzc2lvbnNSZXNwb25zZS5kYXRhIGFzIFR1dG9yaW5nU2Vzc2lvbltdO1xuICAgICAgXG4gICAgICAvLyBHZXQgdHV0b3IncyBwcm9maWxlXG4gICAgICBjb25zdCBwcm9maWxlUmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoYCR7QVBJX1VSTH0vdXNlcnMvdHV0b3JzL3Byb2ZpbGUvbWVgLCB7IGhlYWRlcnMgfSk7XG4gICAgICBjb25zdCBwcm9maWxlID0gcHJvZmlsZVJlc3BvbnNlLmRhdGE7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBzdGF0cyBmcm9tIHNlc3Npb25zIGRhdGFcbiAgICAgIGNvbnN0IGNvbXBsZXRlZFNlc3Npb25zID0gYWxsU2Vzc2lvbnMuZmlsdGVyKHNlc3Npb24gPT4gc2Vzc2lvbi5zdGF0dXMgPT09ICdjb21wbGV0ZWQnKTtcbiAgICAgIGNvbnN0IHVwY29taW5nU2Vzc2lvbnMgPSBhbGxTZXNzaW9ucy5maWx0ZXIoc2Vzc2lvbiA9PiBbJ3NjaGVkdWxlZCcsICdjb25maXJtZWQnXS5pbmNsdWRlcyhzZXNzaW9uLnN0YXR1cykpO1xuICAgICAgY29uc3QgdG90YWxIb3VycyA9IGNvbXBsZXRlZFNlc3Npb25zLnJlZHVjZSgodG90YWwsIHNlc3Npb24pID0+IHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBuZXcgRGF0ZShzZXNzaW9uLnN0YXJ0VGltZSkuZ2V0VGltZSgpO1xuICAgICAgICBjb25zdCBlbmQgPSBuZXcgRGF0ZShzZXNzaW9uLmVuZFRpbWUpLmdldFRpbWUoKTtcbiAgICAgICAgY29uc3QgaG91cnMgPSAoZW5kIC0gc3RhcnQpIC8gKDEwMDAgKiA2MCAqIDYwKTsgLy8gQ29udmVydCBtaWxsaXNlY29uZHMgdG8gaG91cnNcbiAgICAgICAgcmV0dXJuIHRvdGFsICsgaG91cnM7XG4gICAgICB9LCAwKTtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIG1vbnRobHkgZWFybmluZ3MgKGFzc3VtaW5nIHNlc3Npb25zIGhhdmUgYSBwcmljZSBmaWVsZCBvciB1c2luZyBhIGRlZmF1bHQgcmF0ZSlcbiAgICAgIGNvbnN0IGN1cnJlbnRNb250aCA9IG5ldyBEYXRlKCkuZ2V0TW9udGgoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRZZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuICAgICAgY29uc3QgdGhpc01vbnRoQ29tcGxldGVkU2Vzc2lvbnMgPSBjb21wbGV0ZWRTZXNzaW9ucy5maWx0ZXIoc2Vzc2lvbiA9PiB7XG4gICAgICAgIGNvbnN0IHNlc3Npb25EYXRlID0gbmV3IERhdGUoc2Vzc2lvbi5lbmRUaW1lKTtcbiAgICAgICAgcmV0dXJuIHNlc3Npb25EYXRlLmdldE1vbnRoKCkgPT09IGN1cnJlbnRNb250aCAmJiBzZXNzaW9uRGF0ZS5nZXRGdWxsWWVhcigpID09PSBjdXJyZW50WWVhcjtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBBc3N1bWluZyBhbiBhdmVyYWdlIHJhdGUgb2YgJDQwL2hvdXIgZm9yIGNhbGN1bGF0aW9uXG4gICAgICBjb25zdCBob3VybHlSYXRlID0gNDA7XG4gICAgICBjb25zdCBtb250aGx5RWFybmluZ3MgPSB0aGlzTW9udGhDb21wbGV0ZWRTZXNzaW9ucy5yZWR1Y2UoKHRvdGFsLCBzZXNzaW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gbmV3IERhdGUoc2Vzc2lvbi5zdGFydFRpbWUpLmdldFRpbWUoKTtcbiAgICAgICAgY29uc3QgZW5kID0gbmV3IERhdGUoc2Vzc2lvbi5lbmRUaW1lKS5nZXRUaW1lKCk7XG4gICAgICAgIGNvbnN0IGhvdXJzID0gKGVuZCAtIHN0YXJ0KSAvICgxMDAwICogNjAgKiA2MCk7XG4gICAgICAgIHJldHVybiB0b3RhbCArIChob3VycyAqIGhvdXJseVJhdGUpO1xuICAgICAgfSwgMCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHRvdGFsRWFybmluZ3MgPSBjb21wbGV0ZWRTZXNzaW9ucy5yZWR1Y2UoKHRvdGFsLCBzZXNzaW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gbmV3IERhdGUoc2Vzc2lvbi5zdGFydFRpbWUpLmdldFRpbWUoKTtcbiAgICAgICAgY29uc3QgZW5kID0gbmV3IERhdGUoc2Vzc2lvbi5lbmRUaW1lKS5nZXRUaW1lKCk7XG4gICAgICAgIGNvbnN0IGhvdXJzID0gKGVuZCAtIHN0YXJ0KSAvICgxMDAwICogNjAgKiA2MCk7XG4gICAgICAgIHJldHVybiB0b3RhbCArIChob3VycyAqIGhvdXJseVJhdGUpO1xuICAgICAgfSwgMCk7XG4gICAgICBcbiAgICAgIC8vIFJldHVybiBjYWxjdWxhdGVkIHN0YXRpc3RpY3NcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJhdGluZzogNC41LCAvLyBQbGFjZWhvbGRlciByYXRpbmdcbiAgICAgICAgcmV2aWV3czogY29tcGxldGVkU2Vzc2lvbnMubGVuZ3RoLCAvLyBBc3N1bWluZyAxIHJldmlldyBwZXIgY29tcGxldGVkIHNlc3Npb25cbiAgICAgICAgdG90YWxFYXJuaW5nczogTWF0aC5yb3VuZCh0b3RhbEVhcm5pbmdzKSxcbiAgICAgICAgbW9udGhseUVhcm5pbmdzOiBNYXRoLnJvdW5kKG1vbnRobHlFYXJuaW5ncyksXG4gICAgICAgIHVwY29taW5nU2Vzc2lvbnM6IHVwY29taW5nU2Vzc2lvbnMubGVuZ3RoLFxuICAgICAgICB0b3RhbEhvdXJzOiBNYXRoLnJvdW5kKHRvdGFsSG91cnMgKiAxMCkgLyAxMCwgLy8gUm91bmQgdG8gMSBkZWNpbWFsIHBsYWNlXG4gICAgICAgIGNvbXBsZXRlZFNlc3Npb25zOiBjb21wbGV0ZWRTZXNzaW9ucy5sZW5ndGgsXG4gICAgICAgIHN1YmplY3RzOiBbJ01hdGgnLCAnU2NpZW5jZScsICdFbmdsaXNoJ10gLy8gUGxhY2Vob2xkZXIgc3ViamVjdHNcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNhbGN1bGF0aW5nIHR1dG9yIHN0YXRzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJhdGluZzogMCxcbiAgICAgICAgcmV2aWV3czogMCxcbiAgICAgICAgdG90YWxFYXJuaW5nczogMCxcbiAgICAgICAgbW9udGhseUVhcm5pbmdzOiAwLFxuICAgICAgICB1cGNvbWluZ1Nlc3Npb25zOiAwLFxuICAgICAgICB0b3RhbEhvdXJzOiAwLFxuICAgICAgICBjb21wbGV0ZWRTZXNzaW9uczogMCxcbiAgICAgICAgc3ViamVjdHM6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYXZhaWxhYmxlIHN0dWRlbnRzIGZvciB0dXRvcmluZyBzZXNzaW9uc1xuICAgKiBGZXRjaGVzIHRoZSBsaXN0IG9mIHN0dWRlbnRzIHRoYXQgdGhlIHR1dG9yIGNhbiBjcmVhdGUgc2Vzc2lvbnMgd2l0aFxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggYXJyYXkgb2Ygc3R1ZGVudCBkYXRhXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZ2V0QXZhaWxhYmxlU3R1ZGVudHMoKTogUHJvbWlzZTxTdHVkZW50W10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuZ2V0QXV0aEhlYWRlcnMoKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KGAke0FQSV9VUkx9L3VzZXJzL2NoaWxkcmVuL3R1dG9yaW5nL2F2YWlsYWJsZS1zdHVkZW50c2AsIHsgaGVhZGVycyB9KTtcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBhdmFpbGFibGUgc3R1ZGVudHM6JywgZXJyb3IpO1xuICAgICAgLy8gUmV0dXJuIGVtcHR5IGFycmF5IG9uIGVycm9yXG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhIHNlc3Npb24ncyBzdGF0dXNcbiAgICogQHBhcmFtIHNlc3Npb25JZCBUaGUgSUQgb2YgdGhlIHNlc3Npb24gdG8gdXBkYXRlXG4gICAqIEBwYXJhbSBzdGF0dXMgVGhlIG5ldyBzdGF0dXMgdG8gc2V0XG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCB0aGUgdXBkYXRlZCBzZXNzaW9uIGRhdGFcbiAgICovXG4gIHN0YXRpYyBhc3luYyB1cGRhdGVTZXNzaW9uU3RhdHVzKHNlc3Npb25JZDogbnVtYmVyLCBzdGF0dXM6IHN0cmluZyk6IFByb21pc2U8VHV0b3JpbmdTZXNzaW9uPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmdldEF1dGhIZWFkZXJzKCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLnBhdGNoKFxuICAgICAgICBgJHtBUElfVVJMfS90dXRvcnMvc2Vzc2lvbnMvJHtzZXNzaW9uSWR9L3N0YXR1c2AsXG4gICAgICAgIHsgc3RhdHVzIH0sXG4gICAgICAgIHsgaGVhZGVycyB9XG4gICAgICApO1xuICAgICAgXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgdXBkYXRpbmcgc2Vzc2lvbiAke3Nlc3Npb25JZH0gc3RhdHVzOmAsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yOyAvLyBSZXRocm93IHRvIGxldCB0aGUgY29tcG9uZW50IGhhbmRsZSB0aGUgZXJyb3JcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJheGlvcyIsIkFQSV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsImlzQ2xpZW50IiwiZmV0Y2hDaGlsZERldGFpbHMiLCJjaGlsZElkIiwidG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiZSIsImNvbnNvbGUiLCJlcnJvciIsImxvZyIsImhlYWRlcnMiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwib2siLCJlcnJvclRleHQiLCJ0ZXh0Iiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImJvZHkiLCJFcnJvciIsImRhdGEiLCJqc29uIiwiZmV0Y2hTdWJqZWN0RGV0YWlscyIsInN1YmplY3RJZCIsIlR1dG9yRGFzaGJvYXJkU2VydmljZSIsImdldEF1dGhIZWFkZXJzIiwic2Vzc2lvblN0b3JhZ2UiLCJzdGFydHNXaXRoIiwidHJpbSIsIm9yaWdpbmFsVG9rZW5MZW5ndGgiLCJsZW5ndGgiLCJBdXRob3JpemF0aW9uIiwiZ2V0VHV0b3JTdGF0cyIsImdldCIsInJhdGluZyIsInJldmlld3MiLCJ0b3RhbEVhcm5pbmdzIiwibW9udGhseUVhcm5pbmdzIiwidXBjb21pbmdTZXNzaW9ucyIsInRvdGFsSG91cnMiLCJjb21wbGV0ZWRTZXNzaW9ucyIsInN1YmplY3RzIiwiZ2V0VXBjb21pbmdTZXNzaW9ucyIsImxpbWl0IiwiZmlsdGVyIiwic2Vzc2lvbiIsImluY2x1ZGVzIiwic29ydCIsImEiLCJiIiwiRGF0ZSIsInN0YXJ0VGltZSIsImdldFRpbWUiLCJzbGljZSIsImdldFJlY2VudEZlZWRiYWNrIiwicmVjZW50RmVlZGJhY2siLCJjcmVhdGVkQXQiLCJnZXRSZWNlbnRBc3NpZ25tZW50cyIsInJlY2VudEFzc2lnbm1lbnRzIiwiZHVlRGF0ZSIsInF1aWNrQXNzaWduSG9tZXdvcmsiLCJhc3NpZ25tZW50RGF0YSIsInBvc3QiLCJnZXRBdmFpbGFibGVTdHVkZW50cyIsInRpbWVzdGFtcCIsInBhcmFtcyIsIl8iLCJjcmVhdGVTZXNzaW9uIiwic2Vzc2lvbkRhdGEiLCJmb3JtYXR0ZWRUb2tlbiIsImF1dGhIZWFkZXJMZW5ndGgiLCJoYXNCZWFyZXJQcmVmaXgiLCJOdW1iZXIiLCJkdXJhdGlvbk1pbnV0ZXMiLCJlbmRUaW1lIiwiTWF0aCIsInJvdW5kIiwic2V0SXRlbSIsImdldENvbXBsZXRlZFNlc3Npb25zIiwiY2FsY3VsYXRlVHV0b3JTdGF0cyIsInNlc3Npb25zUmVzcG9uc2UiLCJhbGxTZXNzaW9ucyIsInByb2ZpbGVSZXNwb25zZSIsInByb2ZpbGUiLCJyZWR1Y2UiLCJ0b3RhbCIsInN0YXJ0IiwiZW5kIiwiaG91cnMiLCJjdXJyZW50TW9udGgiLCJnZXRNb250aCIsImN1cnJlbnRZZWFyIiwiZ2V0RnVsbFllYXIiLCJ0aGlzTW9udGhDb21wbGV0ZWRTZXNzaW9ucyIsInNlc3Npb25EYXRlIiwiaG91cmx5UmF0ZSIsInVwZGF0ZVNlc3Npb25TdGF0dXMiLCJzZXNzaW9uSWQiLCJwYXRjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/tutor-dashboard.service.ts\n"));

/***/ })

});