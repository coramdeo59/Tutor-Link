"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(dashboard)/tutor-dashboard/sessions/page",{

/***/ "(app-pages-browser)/./src/services/tutor-dashboard.service.ts":
/*!*************************************************!*\
  !*** ./src/services/tutor-dashboard.service.ts ***!
  \*************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TutorDashboardService: function() { return /* binding */ TutorDashboardService; },\n/* harmony export */   fetchChildDetails: function() { return /* binding */ fetchChildDetails; },\n/* harmony export */   fetchSubjectDetails: function() { return /* binding */ fetchSubjectDetails; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/.pnpm/axios@1.9.0/node_modules/axios/lib/axios.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.28_@babel+core@7.27.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/build/polyfills/process.js\");\n\"use clinet\";\n\nconst API_URL = process.env.NEXT_PUBLIC_API_URL || \"http://localhost:3001\";\n// Safely check if window is defined (client-side only)\nconst isClient = \"object\" !== \"undefined\";\n// Fetches child details from the backend by ID\nconst fetchChildDetails = async (childId)=>{\n    try {\n        // Get token from localStorage - only in client environment\n        let token;\n        if (isClient) {\n            try {\n                token = localStorage.getItem(\"accessToken\");\n            } catch (e) {\n                console.error(\"Error accessing localStorage:\", e);\n                return null;\n            }\n        } else {\n            // Server-side fallback (Next.js SSR)\n            console.log(\"Running in server environment, using default token\");\n            token = \"\";\n        }\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": \"Bearer \".concat(token)\n        };\n        const response = await fetch(\"\".concat(API_URL, \"/users/children/tutoring/child/\").concat(childId), {\n            method: \"GET\",\n            headers\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            console.error(\"Error fetching child details:\", {\n                status: response.status,\n                statusText: response.statusText,\n                body: errorText\n            });\n            throw new Error(\"Error \".concat(response.status, \": \").concat(errorText));\n        }\n        const data = await response.json();\n        return data;\n    } catch (error) {\n        console.error(\"Error fetching child details for ID \".concat(childId, \":\"), error);\n        return null;\n    }\n};\n// Fetches subject details from the backend by ID\nconst fetchSubjectDetails = async (subjectId)=>{\n    try {\n        // Get token from localStorage - only in client environment\n        let token;\n        if (isClient) {\n            try {\n                token = localStorage.getItem(\"accessToken\");\n            } catch (e) {\n                console.error(\"Error accessing localStorage:\", e);\n                return null;\n            }\n        } else {\n            // Server-side fallback (Next.js SSR)\n            console.log(\"Running in server environment, using default token\");\n            token = \"\";\n        }\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": \"Bearer \".concat(token)\n        };\n        const response = await fetch(\"\".concat(API_URL, \"/subjectAndGrade/subjects/\").concat(subjectId), {\n            method: \"GET\",\n            headers\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            console.error(\"Error fetching subject details:\", {\n                status: response.status,\n                statusText: response.statusText,\n                body: errorText\n            });\n            throw new Error(\"Error \".concat(response.status, \": \").concat(errorText));\n        }\n        const data = await response.json();\n        return data;\n    } catch (error) {\n        console.error(\"Error fetching subject details for ID \".concat(subjectId, \":\"), error);\n        return null;\n    }\n};\n/**\n * TutorDashboardService\n * Handles API calls related to the tutor dashboard\n */ class TutorDashboardService {\n    /**\n   * Get authentication headers\n   * @returns Headers object with Authorization token\n   */ static getAuthHeaders() {\n        // Try multiple possible token keys to handle inconsistencies\n        let token = localStorage.getItem(\"token\") || localStorage.getItem(\"accessToken\") || sessionStorage.getItem(\"accessToken\");\n        // First, check for existing token with Bearer prefix (important!)    \n        if (token && token.startsWith(\"Bearer \")) {\n            // Token already has Bearer prefix - leave as is\n            console.log(\"Token already has Bearer prefix\");\n        } else {\n            // Check if token exists and is not malformed\n            if (!token || token === \"undefined\" || token === \"null\") {\n                console.error(\"Auth token is missing or invalid\");\n                // For now, fallback to empty token to make the error more obvious in API responses\n                token = \"\";\n            } else {\n                // Ensure token is properly trimmed to avoid whitespace issues\n                token = token.trim();\n                // Store original form for diagnostics\n                const originalTokenLength = token.length;\n                // Add Bearer prefix only if it's not already there\n                if (!token.startsWith(\"Bearer \")) {\n                    token = \"Bearer \".concat(token);\n                }\n                console.log(\"Processed token: original length=\".concat(originalTokenLength, \", new length=\").concat(token.length));\n            }\n        }\n        // Return headers with Authorization if token exists\n        return {\n            Authorization: token,\n            \"Content-Type\": \"application/json\"\n        };\n    }\n    /**\n   * Get tutor stats for dashboard\n   * @returns Promise with tutor stats\n   */ static async getTutorStats() {\n        try {\n            const headers = this.getAuthHeaders();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/users/tutors/dashboard/stats\"), {\n                headers\n            });\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching tutor stats:\", error);\n            // Return default stats if API fails\n            return {\n                rating: 0,\n                reviews: 0,\n                totalEarnings: 0,\n                monthlyEarnings: 0,\n                upcomingSessions: 0,\n                totalHours: 0,\n                completedSessions: 0,\n                subjects: []\n            };\n        }\n    }\n    /**\n   * Get upcoming sessions for the tutor\n   * @param limit Number of sessions to return\n   * @returns Promise with sessions data\n   */ static async getUpcomingSessions() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5;\n        try {\n            const headers = this.getAuthHeaders();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/tutors/sessions/my-sessions\"), {\n                headers\n            });\n            // Filter the sessions by status and limit the results on the client side\n            const upcomingSessions = response.data.filter((session)=>[\n                    \"scheduled\",\n                    \"confirmed\"\n                ].includes(session.status)).sort((a, b)=>new Date(a.startTime).getTime() - new Date(b.startTime).getTime()).slice(0, limit);\n            return upcomingSessions;\n        } catch (error) {\n            console.error(\"Error fetching upcoming sessions:\", error);\n            return [];\n        }\n    }\n    /**\n   * Get recent feedback provided by the tutor\n   * @param limit Number of feedback items to return\n   * @returns Promise with feedback data\n   */ static async getRecentFeedback() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5;\n        try {\n            const headers = this.getAuthHeaders();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/tutors/feedback/my-feedback\"), {\n                headers\n            });\n            // Process and limit the feedback data on the client side\n            const recentFeedback = response.data.sort((a, b)=>new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()).slice(0, limit);\n            return recentFeedback;\n        } catch (error) {\n            console.error(\"Error fetching recent feedback:\", error);\n            return [];\n        }\n    }\n    /**\n   * Get assignments created by the tutor\n   * @param limit Number of assignments to return\n   * @returns Promise with assignments data\n   */ static async getRecentAssignments() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5;\n        try {\n            const headers = this.getAuthHeaders();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/tutors/assignments/my-assignments\"), {\n                headers\n            });\n            // Process and limit the assignments data on the client side\n            // Sort by due date with closest due dates first\n            const recentAssignments = response.data.sort((a, b)=>new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime()).slice(0, limit);\n            return recentAssignments;\n        } catch (error) {\n            console.error(\"Error fetching recent assignments:\", error);\n            return [];\n        }\n    }\n    /**\n   * Quick assign homework to a student\n   * @param assignmentData Object containing assignment details\n   * @returns Promise with assignment creation result\n   */ static async quickAssignHomework(assignmentData) {\n        try {\n            const headers = this.getAuthHeaders();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(\"\".concat(API_URL, \"/tutors/assignments/quick-assign\"), assignmentData, {\n                headers\n            });\n            return response.data;\n        } catch (error) {\n            console.error(\"Error creating quick assignment:\", error);\n            throw error;\n        }\n    }\n    // This implementation is now removed as it's a duplicate of the one below\n    /**\n   * Create a new tutoring session\n   * @param sessionData The data for the new tutoring session\n   * @returns Promise with the created session data\n   */ static async createSession(sessionData) {\n        try {\n            var _headers_Authorization, _headers_Authorization1;\n            // Get token directly to ensure we're using the latest formatted version\n            const token = localStorage.getItem(\"token\") || localStorage.getItem(\"accessToken\") || sessionStorage.getItem(\"accessToken\");\n            // Format token if needed\n            const formattedToken = token && !token.startsWith(\"Bearer \") ? \"Bearer \".concat(token.trim()) : token;\n            // Use the formatted token directly\n            const headers = {\n                Authorization: formattedToken,\n                \"Content-Type\": \"application/json\"\n            };\n            console.log(\"Creating session with headers:\", {\n                authHeaderLength: ((_headers_Authorization = headers.Authorization) === null || _headers_Authorization === void 0 ? void 0 : _headers_Authorization.length) || 0,\n                hasBearerPrefix: ((_headers_Authorization1 = headers.Authorization) === null || _headers_Authorization1 === void 0 ? void 0 : _headers_Authorization1.startsWith(\"Bearer \")) || false\n            });\n            console.log(\"Creating session with data:\", {\n                ...sessionData,\n                childId: Number(sessionData.childId),\n                subjectId: Number(sessionData.subjectId)\n            });\n            // Make direct API call with the formatted header\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(\"\".concat(API_URL, \"/tutors/sessions\"), {\n                ...sessionData,\n                childId: Number(sessionData.childId),\n                subjectId: Number(sessionData.subjectId),\n                // Add durationMinutes if it doesn't exist\n                durationMinutes: sessionData.durationMinutes || (sessionData.startTime && sessionData.endTime ? Math.round((new Date(sessionData.endTime).getTime() - new Date(sessionData.startTime).getTime()) / 60000) : 60)\n            }, {\n                headers\n            });\n            console.log(\"Session created successfully:\", response.data);\n            // Store the token with Bearer prefix for future use\n            if (formattedToken) {\n                localStorage.setItem(\"token\", formattedToken);\n                localStorage.setItem(\"accessToken\", formattedToken);\n            }\n            return response.data;\n        } catch (error) {\n            console.error(\"Error creating session:\", error);\n            if (error.response) {\n                console.error(\"Error response data:\", error.response.data);\n                console.error(\"Error response status:\", error.response.status);\n            }\n            throw error;\n        }\n    }\n    /**\n   * Get completed sessions for the tutor\n   * @param limit Number of sessions to return\n   * @returns Promise with sessions data\n   */ static async getCompletedSessions() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5;\n        try {\n            const headers = this.getAuthHeaders();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/tutors/sessions/my-sessions\"), {\n                headers\n            });\n            // Filter to only include completed sessions and sort by most recent first\n            const completedSessions = response.data.filter((session)=>session.status === \"completed\").sort((a, b)=>new Date(b.endTime).getTime() - new Date(a.endTime).getTime()).slice(0, limit);\n            return completedSessions;\n        } catch (error) {\n            console.error(\"Error fetching completed sessions:\", error);\n            return [];\n        }\n    }\n    /**\n   * Calculate tutor statistics based on all available data\n   * @returns Promise with calculated statistics\n   */ static async calculateTutorStats() {\n        try {\n            // Get all sessions to calculate stats\n            const headers = this.getAuthHeaders();\n            const sessionsResponse = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/tutors/sessions/my-sessions\"), {\n                headers\n            });\n            const allSessions = sessionsResponse.data;\n            // Get tutor's profile\n            const profileResponse = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/users/tutors/profile/me\"), {\n                headers\n            });\n            const profile = profileResponse.data;\n            // Calculate stats from sessions data\n            const completedSessions = allSessions.filter((session)=>session.status === \"completed\");\n            const upcomingSessions = allSessions.filter((session)=>[\n                    \"scheduled\",\n                    \"confirmed\"\n                ].includes(session.status));\n            const totalHours = completedSessions.reduce((total, session)=>{\n                const start = new Date(session.startTime).getTime();\n                const end = new Date(session.endTime).getTime();\n                const hours = (end - start) / (1000 * 60 * 60); // Convert milliseconds to hours\n                return total + hours;\n            }, 0);\n            // Calculate monthly earnings (assuming sessions have a price field or using a default rate)\n            const currentMonth = new Date().getMonth();\n            const currentYear = new Date().getFullYear();\n            const thisMonthCompletedSessions = completedSessions.filter((session)=>{\n                const sessionDate = new Date(session.endTime);\n                return sessionDate.getMonth() === currentMonth && sessionDate.getFullYear() === currentYear;\n            });\n            // Assuming an average rate of $40/hour for calculation\n            const hourlyRate = 40;\n            const monthlyEarnings = thisMonthCompletedSessions.reduce((total, session)=>{\n                const start = new Date(session.startTime).getTime();\n                const end = new Date(session.endTime).getTime();\n                const hours = (end - start) / (1000 * 60 * 60);\n                return total + hours * hourlyRate;\n            }, 0);\n            const totalEarnings = completedSessions.reduce((total, session)=>{\n                const start = new Date(session.startTime).getTime();\n                const end = new Date(session.endTime).getTime();\n                const hours = (end - start) / (1000 * 60 * 60);\n                return total + hours * hourlyRate;\n            }, 0);\n            // Return calculated statistics\n            return {\n                rating: 4.5,\n                reviews: completedSessions.length,\n                totalEarnings: Math.round(totalEarnings),\n                monthlyEarnings: Math.round(monthlyEarnings),\n                upcomingSessions: upcomingSessions.length,\n                totalHours: Math.round(totalHours * 10) / 10,\n                completedSessions: completedSessions.length,\n                subjects: [\n                    \"Math\",\n                    \"Science\",\n                    \"English\"\n                ] // Placeholder subjects\n            };\n        } catch (error) {\n            console.error(\"Error calculating tutor stats:\", error);\n            return {\n                rating: 0,\n                reviews: 0,\n                totalEarnings: 0,\n                monthlyEarnings: 0,\n                upcomingSessions: 0,\n                totalHours: 0,\n                completedSessions: 0,\n                subjects: []\n            };\n        }\n    }\n    /**\n   * Fetches the list of students that the tutor can create sessions and assignments with\n   * @returns Promise with array of student data\n   */ static async getAvailableStudents() {\n        try {\n            const headers = this.getAuthHeaders();\n            // Add cache-busting query parameter\n            const timestamp = new Date().getTime();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/users/children/tutoring/available-students?_=\").concat(timestamp), {\n                headers: {\n                    ...headers,\n                    \"Cache-Control\": \"no-cache, no-store\",\n                    \"Pragma\": \"no-cache\"\n                }\n            });\n            console.log(\"Available students response:\", response.status, response.data);\n            return response.data || [];\n        } catch (error) {\n            var _error_response;\n            console.error(\"Error fetching available students:\", error);\n            console.log(\"Error details:\", ((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.data) || error.message);\n            // Return empty array on error\n            return [];\n        }\n    }\n    /**\n   * Update a session's status\n   * @param sessionId The ID of the session to update\n   * @param status The new status to set\n   * @returns Promise with the updated session data\n   */ static async updateSessionStatus(sessionId, status) {\n        try {\n            const headers = this.getAuthHeaders();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].patch(\"\".concat(API_URL, \"/tutors/sessions/\").concat(sessionId, \"/status\"), {\n                status\n            }, {\n                headers\n            });\n            return response.data;\n        } catch (error) {\n            console.error(\"Error updating session \".concat(sessionId, \" status:\"), error);\n            throw error; // Rethrow to let the component handle the error\n        }\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy90dXRvci1kYXNoYm9hcmQuc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQzBCO0FBRTFCLE1BQU1DLFVBQVVDLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsbUJBQW1CLElBQUk7QUE4Q25ELHVEQUF1RDtBQUN2RCxNQUFNQyxXQUFXLGFBQWtCO0FBRW5DLCtDQUErQztBQUN4QyxNQUFNQyxvQkFBb0IsT0FBT0M7SUFDdEMsSUFBSTtRQUNGLDJEQUEyRDtRQUMzRCxJQUFJQztRQUNKLElBQUlILFVBQVU7WUFDWixJQUFJO2dCQUNGRyxRQUFRQyxhQUFhQyxPQUFPLENBQUM7WUFDL0IsRUFBRSxPQUFPQyxHQUFHO2dCQUNWQyxRQUFRQyxLQUFLLENBQUMsaUNBQWlDRjtnQkFDL0MsT0FBTztZQUNUO1FBQ0YsT0FBTztZQUNMLHFDQUFxQztZQUNyQ0MsUUFBUUUsR0FBRyxDQUFDO1lBQ1pOLFFBQVE7UUFDVjtRQUVBLE1BQU1PLFVBQVU7WUFDZCxnQkFBZ0I7WUFDaEIsaUJBQWlCLFVBQWdCLE9BQU5QO1FBQzdCO1FBRUEsTUFBTVEsV0FBVyxNQUFNQyxNQUFNLEdBQTRDVixPQUF6Q04sU0FBUSxtQ0FBeUMsT0FBUk0sVUFBVztZQUNsRlcsUUFBUTtZQUNSSDtRQUNGO1FBRUEsSUFBSSxDQUFDQyxTQUFTRyxFQUFFLEVBQUU7WUFDaEIsTUFBTUMsWUFBWSxNQUFNSixTQUFTSyxJQUFJO1lBQ3JDVCxRQUFRQyxLQUFLLENBQUUsaUNBQWdDO2dCQUM3Q1MsUUFBUU4sU0FBU00sTUFBTTtnQkFDdkJDLFlBQVlQLFNBQVNPLFVBQVU7Z0JBQy9CQyxNQUFNSjtZQUNSO1lBQ0EsTUFBTSxJQUFJSyxNQUFNLFNBQTZCTCxPQUFwQkosU0FBU00sTUFBTSxFQUFDLE1BQWMsT0FBVkY7UUFDL0M7UUFFQSxNQUFNTSxPQUFPLE1BQU1WLFNBQVNXLElBQUk7UUFDaEMsT0FBT0Q7SUFDVCxFQUFFLE9BQU9iLE9BQU87UUFDZEQsUUFBUUMsS0FBSyxDQUFDLHVDQUErQyxPQUFSTixTQUFRLE1BQUlNO1FBQ2pFLE9BQU87SUFDVDtBQUNGLEVBQUU7QUFFRixpREFBaUQ7QUFDMUMsTUFBTWUsc0JBQXNCLE9BQU9DO0lBQ3hDLElBQUk7UUFDRiwyREFBMkQ7UUFDM0QsSUFBSXJCO1FBQ0osSUFBSUgsVUFBVTtZQUNaLElBQUk7Z0JBQ0ZHLFFBQVFDLGFBQWFDLE9BQU8sQ0FBQztZQUMvQixFQUFFLE9BQU9DLEdBQUc7Z0JBQ1ZDLFFBQVFDLEtBQUssQ0FBQyxpQ0FBaUNGO2dCQUMvQyxPQUFPO1lBQ1Q7UUFDRixPQUFPO1lBQ0wscUNBQXFDO1lBQ3JDQyxRQUFRRSxHQUFHLENBQUM7WUFDWk4sUUFBUTtRQUNWO1FBRUEsTUFBTU8sVUFBVTtZQUNkLGdCQUFnQjtZQUNoQixpQkFBaUIsVUFBZ0IsT0FBTlA7UUFDN0I7UUFFQSxNQUFNUSxXQUFXLE1BQU1DLE1BQU0sR0FBdUNZLE9BQXBDNUIsU0FBUSw4QkFBc0MsT0FBVjRCLFlBQWE7WUFDL0VYLFFBQVE7WUFDUkg7UUFDRjtRQUVBLElBQUksQ0FBQ0MsU0FBU0csRUFBRSxFQUFFO1lBQ2hCLE1BQU1DLFlBQVksTUFBTUosU0FBU0ssSUFBSTtZQUNyQ1QsUUFBUUMsS0FBSyxDQUFFLG1DQUFrQztnQkFDL0NTLFFBQVFOLFNBQVNNLE1BQU07Z0JBQ3ZCQyxZQUFZUCxTQUFTTyxVQUFVO2dCQUMvQkMsTUFBTUo7WUFDUjtZQUNBLE1BQU0sSUFBSUssTUFBTSxTQUE2QkwsT0FBcEJKLFNBQVNNLE1BQU0sRUFBQyxNQUFjLE9BQVZGO1FBQy9DO1FBRUEsTUFBTU0sT0FBTyxNQUFNVixTQUFTVyxJQUFJO1FBQ2hDLE9BQU9EO0lBQ1QsRUFBRSxPQUFPYixPQUFPO1FBQ2RELFFBQVFDLEtBQUssQ0FBQyx5Q0FBbUQsT0FBVmdCLFdBQVUsTUFBSWhCO1FBQ3JFLE9BQU87SUFDVDtBQUNGLEVBQUM7QUFpQ0Q7OztDQUdDLEdBQ00sTUFBTWlCO0lBQ1g7OztHQUdDLEdBQ0QsT0FBZUMsaUJBQXlDO1FBQ3RELDZEQUE2RDtRQUM3RCxJQUFJdkIsUUFBUUMsYUFBYUMsT0FBTyxDQUFDLFlBQ3RCRCxhQUFhQyxPQUFPLENBQUMsa0JBQ3JCc0IsZUFBZXRCLE9BQU8sQ0FBQztRQUVsQyxzRUFBc0U7UUFDdEUsSUFBSUYsU0FBU0EsTUFBTXlCLFVBQVUsQ0FBQyxZQUFZO1lBQ3hDLGdEQUFnRDtZQUNoRHJCLFFBQVFFLEdBQUcsQ0FBQztRQUNkLE9BQU87WUFDTCw2Q0FBNkM7WUFDN0MsSUFBSSxDQUFDTixTQUFTQSxVQUFVLGVBQWVBLFVBQVUsUUFBUTtnQkFDdkRJLFFBQVFDLEtBQUssQ0FBQztnQkFDZCxtRkFBbUY7Z0JBQ25GTCxRQUFRO1lBQ1YsT0FBTztnQkFDTCw4REFBOEQ7Z0JBQzlEQSxRQUFRQSxNQUFNMEIsSUFBSTtnQkFFbEIsc0NBQXNDO2dCQUN0QyxNQUFNQyxzQkFBc0IzQixNQUFNNEIsTUFBTTtnQkFFeEMsbURBQW1EO2dCQUNuRCxJQUFJLENBQUM1QixNQUFNeUIsVUFBVSxDQUFDLFlBQVk7b0JBQ2hDekIsUUFBUSxVQUFnQixPQUFOQTtnQkFDcEI7Z0JBRUFJLFFBQVFFLEdBQUcsQ0FBQyxvQ0FBdUVOLE9BQW5DMkIscUJBQW9CLGlCQUE0QixPQUFiM0IsTUFBTTRCLE1BQU07WUFDakc7UUFDRjtRQUVBLG9EQUFvRDtRQUNwRCxPQUFPO1lBQ0xDLGVBQWU3QjtZQUNmLGdCQUFnQjtRQUNsQjtJQUNGO0lBRUE7OztHQUdDLEdBQ0QsYUFBYThCLGdCQUFxQztRQUNoRCxJQUFJO1lBQ0YsTUFBTXZCLFVBQVUsSUFBSSxDQUFDZ0IsY0FBYztZQUNuQyxNQUFNZixXQUFXLE1BQU1oQiw2Q0FBS0EsQ0FBQ3VDLEdBQUcsQ0FDOUIsR0FBVyxPQUFSdEMsU0FBUSxrQ0FDWDtnQkFBRWM7WUFBUTtZQUdaLE9BQU9DLFNBQVNVLElBQUk7UUFDdEIsRUFBRSxPQUFPYixPQUFPO1lBQ2RELFFBQVFDLEtBQUssQ0FBQywrQkFBK0JBO1lBQzdDLG9DQUFvQztZQUNwQyxPQUFPO2dCQUNMMkIsUUFBUTtnQkFDUkMsU0FBUztnQkFDVEMsZUFBZTtnQkFDZkMsaUJBQWlCO2dCQUNqQkMsa0JBQWtCO2dCQUNsQkMsWUFBWTtnQkFDWkMsbUJBQW1CO2dCQUNuQkMsVUFBVSxFQUFFO1lBQ2Q7UUFDRjtJQUNGO0lBRUE7Ozs7R0FJQyxHQUNELGFBQWFDLHNCQUEyRDtZQUF2Q0MsUUFBQUEsaUVBQVE7UUFDdkMsSUFBSTtZQUNGLE1BQU1sQyxVQUFVLElBQUksQ0FBQ2dCLGNBQWM7WUFDbkMsTUFBTWYsV0FBVyxNQUFNaEIsNkNBQUtBLENBQUN1QyxHQUFHLENBQzlCLEdBQVcsT0FBUnRDLFNBQVEsaUNBQ1g7Z0JBQUVjO1lBQVE7WUFHWix5RUFBeUU7WUFDekUsTUFBTTZCLG1CQUFtQjVCLFNBQVNVLElBQUksQ0FDbkN3QixNQUFNLENBQUMsQ0FBQ0MsVUFBNkI7b0JBQUM7b0JBQWE7aUJBQVksQ0FBQ0MsUUFBUSxDQUFDRCxRQUFRN0IsTUFBTSxHQUN2RitCLElBQUksQ0FBQyxDQUFDQyxHQUFvQkMsSUFBdUIsSUFBSUMsS0FBS0YsRUFBRUcsU0FBUyxFQUFFQyxPQUFPLEtBQUssSUFBSUYsS0FBS0QsRUFBRUUsU0FBUyxFQUFFQyxPQUFPLElBQ2hIQyxLQUFLLENBQUMsR0FBR1Y7WUFFWixPQUFPTDtRQUNULEVBQUUsT0FBTy9CLE9BQU87WUFDZEQsUUFBUUMsS0FBSyxDQUFDLHFDQUFxQ0E7WUFDbkQsT0FBTyxFQUFFO1FBQ1g7SUFDRjtJQUVBOzs7O0dBSUMsR0FDRCxhQUFhK0Msb0JBQWtEO1lBQWhDWCxRQUFBQSxpRUFBUTtRQUNyQyxJQUFJO1lBQ0YsTUFBTWxDLFVBQVUsSUFBSSxDQUFDZ0IsY0FBYztZQUNuQyxNQUFNZixXQUFXLE1BQU1oQiw2Q0FBS0EsQ0FBQ3VDLEdBQUcsQ0FDOUIsR0FBVyxPQUFSdEMsU0FBUSxpQ0FDWDtnQkFBRWM7WUFBUTtZQUdaLHlEQUF5RDtZQUN6RCxNQUFNOEMsaUJBQWlCN0MsU0FBU1UsSUFBSSxDQUNqQzJCLElBQUksQ0FBQyxDQUFDQyxHQUFhQyxJQUFnQixJQUFJQyxLQUFLRCxFQUFFTyxTQUFTLEVBQUVKLE9BQU8sS0FBSyxJQUFJRixLQUFLRixFQUFFUSxTQUFTLEVBQUVKLE9BQU8sSUFDbEdDLEtBQUssQ0FBQyxHQUFHVjtZQUVaLE9BQU9ZO1FBQ1QsRUFBRSxPQUFPaEQsT0FBTztZQUNkRCxRQUFRQyxLQUFLLENBQUMsbUNBQW1DQTtZQUNqRCxPQUFPLEVBQUU7UUFDWDtJQUNGO0lBRUE7Ozs7R0FJQyxHQUNELGFBQWFrRCx1QkFBdUQ7WUFBbENkLFFBQUFBLGlFQUFRO1FBQ3hDLElBQUk7WUFDRixNQUFNbEMsVUFBVSxJQUFJLENBQUNnQixjQUFjO1lBQ25DLE1BQU1mLFdBQVcsTUFBTWhCLDZDQUFLQSxDQUFDdUMsR0FBRyxDQUM5QixHQUFXLE9BQVJ0QyxTQUFRLHVDQUNYO2dCQUFFYztZQUFRO1lBR1osNERBQTREO1lBQzVELGdEQUFnRDtZQUNoRCxNQUFNaUQsb0JBQW9CaEQsU0FBU1UsSUFBSSxDQUNwQzJCLElBQUksQ0FBQyxDQUFDQyxHQUFlQyxJQUFrQixJQUFJQyxLQUFLRixFQUFFVyxPQUFPLEVBQUVQLE9BQU8sS0FBSyxJQUFJRixLQUFLRCxFQUFFVSxPQUFPLEVBQUVQLE9BQU8sSUFDbEdDLEtBQUssQ0FBQyxHQUFHVjtZQUVaLE9BQU9lO1FBQ1QsRUFBRSxPQUFPbkQsT0FBTztZQUNkRCxRQUFRQyxLQUFLLENBQUMsc0NBQXNDQTtZQUNwRCxPQUFPLEVBQUU7UUFDWDtJQUNGO0lBRUE7Ozs7R0FJQyxHQUNELGFBQWFxRCxvQkFBb0JDLGNBT2hDLEVBQUU7UUFDRCxJQUFJO1lBQ0YsTUFBTXBELFVBQVUsSUFBSSxDQUFDZ0IsY0FBYztZQUNuQyxNQUFNZixXQUFXLE1BQU1oQiw2Q0FBS0EsQ0FBQ29FLElBQUksQ0FDL0IsR0FBVyxPQUFSbkUsU0FBUSxxQ0FDWGtFLGdCQUNBO2dCQUFFcEQ7WUFBUTtZQUdaLE9BQU9DLFNBQVNVLElBQUk7UUFDdEIsRUFBRSxPQUFPYixPQUFPO1lBQ2RELFFBQVFDLEtBQUssQ0FBQyxvQ0FBb0NBO1lBQ2xELE1BQU1BO1FBQ1I7SUFDRjtJQUVBLDBFQUEwRTtJQUUxRTs7OztHQUlDLEdBQ0QsYUFBYXdELGNBQWNDLFdBQWdCLEVBQWdCO1FBQ3pELElBQUk7Z0JBaUJrQnZELHdCQUNEQTtZQWpCbkIsd0VBQXdFO1lBQ3hFLE1BQU1QLFFBQVFDLGFBQWFDLE9BQU8sQ0FBQyxZQUNyQkQsYUFBYUMsT0FBTyxDQUFDLGtCQUNyQnNCLGVBQWV0QixPQUFPLENBQUM7WUFFckMseUJBQXlCO1lBQ3pCLE1BQU02RCxpQkFBaUIvRCxTQUFTLENBQUNBLE1BQU15QixVQUFVLENBQUMsYUFDN0IsVUFBdUIsT0FBYnpCLE1BQU0wQixJQUFJLE1BQU8xQjtZQUVoRCxtQ0FBbUM7WUFDbkMsTUFBTU8sVUFBVTtnQkFDZHNCLGVBQWVrQztnQkFDZixnQkFBZ0I7WUFDbEI7WUFFQTNELFFBQVFFLEdBQUcsQ0FBQyxrQ0FBa0M7Z0JBQzVDMEQsa0JBQWtCekQsRUFBQUEseUJBQUFBLFFBQVFzQixhQUFhLGNBQXJCdEIsNkNBQUFBLHVCQUF1QnFCLE1BQU0sS0FBSTtnQkFDbkRxQyxpQkFBaUIxRCxFQUFBQSwwQkFBQUEsUUFBUXNCLGFBQWEsY0FBckJ0Qiw4Q0FBQUEsd0JBQXVCa0IsVUFBVSxDQUFDLGVBQWM7WUFDbkU7WUFFQXJCLFFBQVFFLEdBQUcsQ0FBQywrQkFBK0I7Z0JBQ3pDLEdBQUd3RCxXQUFXO2dCQUNkL0QsU0FBU21FLE9BQU9KLFlBQVkvRCxPQUFPO2dCQUNuQ3NCLFdBQVc2QyxPQUFPSixZQUFZekMsU0FBUztZQUN6QztZQUVBLGlEQUFpRDtZQUNqRCxNQUFNYixXQUFXLE1BQU1oQiw2Q0FBS0EsQ0FBQ29FLElBQUksQ0FDL0IsR0FBVyxPQUFSbkUsU0FBUSxxQkFDWDtnQkFDRSxHQUFHcUUsV0FBVztnQkFDZC9ELFNBQVNtRSxPQUFPSixZQUFZL0QsT0FBTztnQkFDbkNzQixXQUFXNkMsT0FBT0osWUFBWXpDLFNBQVM7Z0JBQ3ZDLDBDQUEwQztnQkFDMUM4QyxpQkFBaUJMLFlBQVlLLGVBQWUsSUFDekNMLENBQUFBLFlBQVliLFNBQVMsSUFBSWEsWUFBWU0sT0FBTyxHQUM3Q0MsS0FBS0MsS0FBSyxDQUFDLENBQUMsSUFBSXRCLEtBQUtjLFlBQVlNLE9BQU8sRUFBRWxCLE9BQU8sS0FBSyxJQUFJRixLQUFLYyxZQUFZYixTQUFTLEVBQUVDLE9BQU8sRUFBQyxJQUFLLFNBQVMsRUFBQztZQUNqSCxHQUNBO2dCQUFFM0M7WUFBUTtZQUdaSCxRQUFRRSxHQUFHLENBQUMsaUNBQWlDRSxTQUFTVSxJQUFJO1lBRTFELG9EQUFvRDtZQUNwRCxJQUFJNkMsZ0JBQWdCO2dCQUNsQjlELGFBQWFzRSxPQUFPLENBQUMsU0FBU1I7Z0JBQzlCOUQsYUFBYXNFLE9BQU8sQ0FBQyxlQUFlUjtZQUN0QztZQUVBLE9BQU92RCxTQUFTVSxJQUFJO1FBQ3RCLEVBQUUsT0FBT2IsT0FBWTtZQUNuQkQsUUFBUUMsS0FBSyxDQUFDLDJCQUEyQkE7WUFDekMsSUFBSUEsTUFBTUcsUUFBUSxFQUFFO2dCQUNsQkosUUFBUUMsS0FBSyxDQUFDLHdCQUF3QkEsTUFBTUcsUUFBUSxDQUFDVSxJQUFJO2dCQUN6RGQsUUFBUUMsS0FBSyxDQUFDLDBCQUEwQkEsTUFBTUcsUUFBUSxDQUFDTSxNQUFNO1lBQy9EO1lBQ0EsTUFBTVQ7UUFDUjtJQUNGO0lBRUE7Ozs7R0FJQyxHQUNELGFBQWFtRSx1QkFBNEQ7WUFBdkMvQixRQUFBQSxpRUFBUTtRQUN4QyxJQUFJO1lBQ0YsTUFBTWxDLFVBQVUsSUFBSSxDQUFDZ0IsY0FBYztZQUNuQyxNQUFNZixXQUFXLE1BQU1oQiw2Q0FBS0EsQ0FBQ3VDLEdBQUcsQ0FDOUIsR0FBVyxPQUFSdEMsU0FBUSxpQ0FDWDtnQkFBRWM7WUFBUTtZQUdaLDBFQUEwRTtZQUMxRSxNQUFNK0Isb0JBQW9COUIsU0FBU1UsSUFBSSxDQUNwQ3dCLE1BQU0sQ0FBQyxDQUFDQyxVQUE2QkEsUUFBUTdCLE1BQU0sS0FBSyxhQUN4RCtCLElBQUksQ0FBQyxDQUFDQyxHQUFvQkMsSUFBdUIsSUFBSUMsS0FBS0QsRUFBRXFCLE9BQU8sRUFBRWxCLE9BQU8sS0FBSyxJQUFJRixLQUFLRixFQUFFc0IsT0FBTyxFQUFFbEIsT0FBTyxJQUM1R0MsS0FBSyxDQUFDLEdBQUdWO1lBRVosT0FBT0g7UUFDVCxFQUFFLE9BQU9qQyxPQUFPO1lBQ2RELFFBQVFDLEtBQUssQ0FBQyxzQ0FBc0NBO1lBQ3BELE9BQU8sRUFBRTtRQUNYO0lBQ0Y7SUFFQTs7O0dBR0MsR0FDRCxhQUFhb0Usc0JBQTJDO1FBQ3RELElBQUk7WUFDRixzQ0FBc0M7WUFDdEMsTUFBTWxFLFVBQVUsSUFBSSxDQUFDZ0IsY0FBYztZQUNuQyxNQUFNbUQsbUJBQW1CLE1BQU1sRiw2Q0FBS0EsQ0FBQ3VDLEdBQUcsQ0FBQyxHQUFXLE9BQVJ0QyxTQUFRLGlDQUErQjtnQkFBRWM7WUFBUTtZQUM3RixNQUFNb0UsY0FBY0QsaUJBQWlCeEQsSUFBSTtZQUV6QyxzQkFBc0I7WUFDdEIsTUFBTTBELGtCQUFrQixNQUFNcEYsNkNBQUtBLENBQUN1QyxHQUFHLENBQUMsR0FBVyxPQUFSdEMsU0FBUSw2QkFBMkI7Z0JBQUVjO1lBQVE7WUFDeEYsTUFBTXNFLFVBQVVELGdCQUFnQjFELElBQUk7WUFFcEMscUNBQXFDO1lBQ3JDLE1BQU1vQixvQkFBb0JxQyxZQUFZakMsTUFBTSxDQUFDQyxDQUFBQSxVQUFXQSxRQUFRN0IsTUFBTSxLQUFLO1lBQzNFLE1BQU1zQixtQkFBbUJ1QyxZQUFZakMsTUFBTSxDQUFDQyxDQUFBQSxVQUFXO29CQUFDO29CQUFhO2lCQUFZLENBQUNDLFFBQVEsQ0FBQ0QsUUFBUTdCLE1BQU07WUFDekcsTUFBTXVCLGFBQWFDLGtCQUFrQndDLE1BQU0sQ0FBQyxDQUFDQyxPQUFPcEM7Z0JBQ2xELE1BQU1xQyxRQUFRLElBQUloQyxLQUFLTCxRQUFRTSxTQUFTLEVBQUVDLE9BQU87Z0JBQ2pELE1BQU0rQixNQUFNLElBQUlqQyxLQUFLTCxRQUFReUIsT0FBTyxFQUFFbEIsT0FBTztnQkFDN0MsTUFBTWdDLFFBQVEsQ0FBQ0QsTUFBTUQsS0FBSSxJQUFNLFFBQU8sS0FBSyxFQUFDLEdBQUksZ0NBQWdDO2dCQUNoRixPQUFPRCxRQUFRRztZQUNqQixHQUFHO1lBRUgsNEZBQTRGO1lBQzVGLE1BQU1DLGVBQWUsSUFBSW5DLE9BQU9vQyxRQUFRO1lBQ3hDLE1BQU1DLGNBQWMsSUFBSXJDLE9BQU9zQyxXQUFXO1lBQzFDLE1BQU1DLDZCQUE2QmpELGtCQUFrQkksTUFBTSxDQUFDQyxDQUFBQTtnQkFDMUQsTUFBTTZDLGNBQWMsSUFBSXhDLEtBQUtMLFFBQVF5QixPQUFPO2dCQUM1QyxPQUFPb0IsWUFBWUosUUFBUSxPQUFPRCxnQkFBZ0JLLFlBQVlGLFdBQVcsT0FBT0Q7WUFDbEY7WUFFQSx1REFBdUQ7WUFDdkQsTUFBTUksYUFBYTtZQUNuQixNQUFNdEQsa0JBQWtCb0QsMkJBQTJCVCxNQUFNLENBQUMsQ0FBQ0MsT0FBT3BDO2dCQUNoRSxNQUFNcUMsUUFBUSxJQUFJaEMsS0FBS0wsUUFBUU0sU0FBUyxFQUFFQyxPQUFPO2dCQUNqRCxNQUFNK0IsTUFBTSxJQUFJakMsS0FBS0wsUUFBUXlCLE9BQU8sRUFBRWxCLE9BQU87Z0JBQzdDLE1BQU1nQyxRQUFRLENBQUNELE1BQU1ELEtBQUksSUFBTSxRQUFPLEtBQUssRUFBQztnQkFDNUMsT0FBT0QsUUFBU0csUUFBUU87WUFDMUIsR0FBRztZQUVILE1BQU12RCxnQkFBZ0JJLGtCQUFrQndDLE1BQU0sQ0FBQyxDQUFDQyxPQUFPcEM7Z0JBQ3JELE1BQU1xQyxRQUFRLElBQUloQyxLQUFLTCxRQUFRTSxTQUFTLEVBQUVDLE9BQU87Z0JBQ2pELE1BQU0rQixNQUFNLElBQUlqQyxLQUFLTCxRQUFReUIsT0FBTyxFQUFFbEIsT0FBTztnQkFDN0MsTUFBTWdDLFFBQVEsQ0FBQ0QsTUFBTUQsS0FBSSxJQUFNLFFBQU8sS0FBSyxFQUFDO2dCQUM1QyxPQUFPRCxRQUFTRyxRQUFRTztZQUMxQixHQUFHO1lBRUgsK0JBQStCO1lBQy9CLE9BQU87Z0JBQ0x6RCxRQUFRO2dCQUNSQyxTQUFTSyxrQkFBa0JWLE1BQU07Z0JBQ2pDTSxlQUFlbUMsS0FBS0MsS0FBSyxDQUFDcEM7Z0JBQzFCQyxpQkFBaUJrQyxLQUFLQyxLQUFLLENBQUNuQztnQkFDNUJDLGtCQUFrQkEsaUJBQWlCUixNQUFNO2dCQUN6Q1MsWUFBWWdDLEtBQUtDLEtBQUssQ0FBQ2pDLGFBQWEsTUFBTTtnQkFDMUNDLG1CQUFtQkEsa0JBQWtCVixNQUFNO2dCQUMzQ1csVUFBVTtvQkFBQztvQkFBUTtvQkFBVztpQkFBVSxDQUFDLHVCQUF1QjtZQUNsRTtRQUNGLEVBQUUsT0FBT2xDLE9BQU87WUFDZEQsUUFBUUMsS0FBSyxDQUFDLGtDQUFrQ0E7WUFDaEQsT0FBTztnQkFDTDJCLFFBQVE7Z0JBQ1JDLFNBQVM7Z0JBQ1RDLGVBQWU7Z0JBQ2ZDLGlCQUFpQjtnQkFDakJDLGtCQUFrQjtnQkFDbEJDLFlBQVk7Z0JBQ1pDLG1CQUFtQjtnQkFDbkJDLFVBQVUsRUFBRTtZQUNkO1FBQ0Y7SUFDRjtJQUVBOzs7R0FHQyxHQUNELGFBQWFtRCx1QkFBdUM7UUFDbEQsSUFBSTtZQUNGLE1BQU1uRixVQUFVLElBQUksQ0FBQ2dCLGNBQWM7WUFFbkMsb0NBQW9DO1lBQ3BDLE1BQU1vRSxZQUFZLElBQUkzQyxPQUFPRSxPQUFPO1lBRXBDLE1BQU0xQyxXQUFXLE1BQU1oQiw2Q0FBS0EsQ0FBQ3VDLEdBQUcsQ0FDOUIsR0FBMkQ0RCxPQUF4RGxHLFNBQVEsa0RBQTBELE9BQVZrRyxZQUMzRDtnQkFDRXBGLFNBQVM7b0JBQ1AsR0FBR0EsT0FBTztvQkFDVixpQkFBaUI7b0JBQ2pCLFVBQVU7Z0JBQ1o7WUFDRjtZQUdGSCxRQUFRRSxHQUFHLENBQUMsZ0NBQWdDRSxTQUFTTSxNQUFNLEVBQUVOLFNBQVNVLElBQUk7WUFDMUUsT0FBT1YsU0FBU1UsSUFBSSxJQUFJLEVBQUU7UUFDNUIsRUFBRSxPQUFPYixPQUFZO2dCQUVXQTtZQUQ5QkQsUUFBUUMsS0FBSyxDQUFDLHNDQUFzQ0E7WUFDcERELFFBQVFFLEdBQUcsQ0FBQyxrQkFBa0JELEVBQUFBLGtCQUFBQSxNQUFNRyxRQUFRLGNBQWRILHNDQUFBQSxnQkFBZ0JhLElBQUksS0FBSWIsTUFBTXVGLE9BQU87WUFDbkUsOEJBQThCO1lBQzlCLE9BQU8sRUFBRTtRQUNYO0lBQ0Y7SUFFQTs7Ozs7R0FLQyxHQUNELGFBQWFDLG9CQUFvQkMsU0FBaUIsRUFBRWhGLE1BQWMsRUFBNEI7UUFDNUYsSUFBSTtZQUNGLE1BQU1QLFVBQVUsSUFBSSxDQUFDZ0IsY0FBYztZQUNuQyxNQUFNZixXQUFXLE1BQU1oQiw2Q0FBS0EsQ0FBQ3VHLEtBQUssQ0FDaEMsR0FBOEJELE9BQTNCckcsU0FBUSxxQkFBNkIsT0FBVnFHLFdBQVUsWUFDeEM7Z0JBQUVoRjtZQUFPLEdBQ1Q7Z0JBQUVQO1lBQVE7WUFHWixPQUFPQyxTQUFTVSxJQUFJO1FBQ3RCLEVBQUUsT0FBT2IsT0FBTztZQUNkRCxRQUFRQyxLQUFLLENBQUMsMEJBQW9DLE9BQVZ5RixXQUFVLGFBQVd6RjtZQUM3RCxNQUFNQSxPQUFPLGdEQUFnRDtRQUMvRDtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3NlcnZpY2VzL3R1dG9yLWRhc2hib2FyZC5zZXJ2aWNlLnRzP2FmOTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGluZXQnXG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuXG5jb25zdCBBUElfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDozMDAxJztcblxuLy8gSW50ZXJmYWNlIGRlZmluaXRpb25zIGZvciB0dXRvciBkYXNoYm9hcmQgZGF0YVxuZXhwb3J0IGludGVyZmFjZSBUdXRvclN0YXRzIHtcbiAgcmF0aW5nOiBudW1iZXI7XG4gIHJldmlld3M6IG51bWJlcjtcbiAgdG90YWxFYXJuaW5nczogbnVtYmVyO1xuICBtb250aGx5RWFybmluZ3M6IG51bWJlcjtcbiAgdXBjb21pbmdTZXNzaW9uczogbnVtYmVyO1xuICB0b3RhbEhvdXJzOiBudW1iZXI7XG4gIGNvbXBsZXRlZFNlc3Npb25zOiBudW1iZXI7XG4gIHN1YmplY3RzOiBzdHJpbmdbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUdXRvcmluZ1Nlc3Npb24ge1xuICBpZD86IG51bWJlcjsgLy8gTmV3IHByaW1hcnkga2V5IGZyb20gYmFja2VuZFxuICBzZXNzaW9uSWQ/OiBudW1iZXI7IC8vIEtlZXAgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgY2hpbGRJZDogbnVtYmVyO1xuICBjaGlsZE5hbWU/OiBzdHJpbmc7XG4gIHN1YmplY3RJZDogbnVtYmVyO1xuICBzdWJqZWN0Pzogc3RyaW5nO1xuICB0aXRsZTogc3RyaW5nO1xuICBzdGFydFRpbWU6IHN0cmluZztcbiAgZW5kVGltZTogc3RyaW5nO1xuICBzdGF0dXM6ICdzY2hlZHVsZWQnIHwgJ2NvbmZpcm1lZCcgfCAnY29tcGxldGVkJyB8ICdjYW5jZWxsZWQnIHwgJ2luX3Byb2dyZXNzJztcbiAgbm90ZXM/OiBzdHJpbmc7XG4gIGR1cmF0aW9uTWludXRlcz86IG51bWJlcjtcbiAgZ3JhZGVMZXZlbE5hbWU/OiBzdHJpbmc7IC8vIEFkZGVkIHRvIG1hdGNoIHRoZSB1c2FnZSBpbiB0aGUgVUlcbn1cblxuLy8gQ2hpbGQgYW5kIHN1YmplY3QgaW5mb3JtYXRpb24gaW50ZXJmYWNlc1xuLy8gVGhlc2UgYXJlIGZvciBBUEkgcmVzcG9uc2VzIGZyb20gdGhlIGRhdGFiYXNlXG5leHBvcnQgaW50ZXJmYWNlIENoaWxkRGV0YWlscyB7XG4gIGNoaWxkSWQ6IG51bWJlcjtcbiAgZmlyc3ROYW1lOiBzdHJpbmc7XG4gIGxhc3ROYW1lOiBzdHJpbmc7XG4gIGZ1bGxOYW1lOiBzdHJpbmc7XG4gIGdyYWRlTGV2ZWxJZD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdWJqZWN0RGV0YWlscyB7XG4gIHN1YmplY3RJZDogbnVtYmVyO1xuICBuYW1lOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xufVxuXG4vLyBTYWZlbHkgY2hlY2sgaWYgd2luZG93IGlzIGRlZmluZWQgKGNsaWVudC1zaWRlIG9ubHkpXG5jb25zdCBpc0NsaWVudCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuXG4vLyBGZXRjaGVzIGNoaWxkIGRldGFpbHMgZnJvbSB0aGUgYmFja2VuZCBieSBJRFxuZXhwb3J0IGNvbnN0IGZldGNoQ2hpbGREZXRhaWxzID0gYXN5bmMgKGNoaWxkSWQ6IG51bWJlcik6IFByb21pc2U8Q2hpbGREZXRhaWxzIHwgbnVsbD4gPT4ge1xuICB0cnkge1xuICAgIC8vIEdldCB0b2tlbiBmcm9tIGxvY2FsU3RvcmFnZSAtIG9ubHkgaW4gY2xpZW50IGVudmlyb25tZW50XG4gICAgbGV0IHRva2VuO1xuICAgIGlmIChpc0NsaWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYWNjZXNzVG9rZW4nKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWNjZXNzaW5nIGxvY2FsU3RvcmFnZTonLCBlKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNlcnZlci1zaWRlIGZhbGxiYWNrIChOZXh0LmpzIFNTUilcbiAgICAgIGNvbnNvbGUubG9nKCdSdW5uaW5nIGluIHNlcnZlciBlbnZpcm9ubWVudCwgdXNpbmcgZGVmYXVsdCB0b2tlbicpO1xuICAgICAgdG9rZW4gPSAnJztcbiAgICB9XG4gICAgXG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gXG4gICAgfTtcbiAgICBcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9VUkx9L3VzZXJzL2NoaWxkcmVuL3R1dG9yaW5nL2NoaWxkLyR7Y2hpbGRJZH1gLCB7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgaGVhZGVyc1xuICAgIH0pO1xuICAgIFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGNoaWxkIGRldGFpbHM6YCwge1xuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgYm9keTogZXJyb3JUZXh0XG4gICAgICB9KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgJHtyZXNwb25zZS5zdGF0dXN9OiAke2Vycm9yVGV4dH1gKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBjaGlsZCBkZXRhaWxzIGZvciBJRCAke2NoaWxkSWR9OmAsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLy8gRmV0Y2hlcyBzdWJqZWN0IGRldGFpbHMgZnJvbSB0aGUgYmFja2VuZCBieSBJRFxuZXhwb3J0IGNvbnN0IGZldGNoU3ViamVjdERldGFpbHMgPSBhc3luYyAoc3ViamVjdElkOiBudW1iZXIpOiBQcm9taXNlPFN1YmplY3REZXRhaWxzIHwgbnVsbD4gPT4ge1xuICB0cnkge1xuICAgIC8vIEdldCB0b2tlbiBmcm9tIGxvY2FsU3RvcmFnZSAtIG9ubHkgaW4gY2xpZW50IGVudmlyb25tZW50XG4gICAgbGV0IHRva2VuO1xuICAgIGlmIChpc0NsaWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYWNjZXNzVG9rZW4nKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWNjZXNzaW5nIGxvY2FsU3RvcmFnZTonLCBlKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNlcnZlci1zaWRlIGZhbGxiYWNrIChOZXh0LmpzIFNTUilcbiAgICAgIGNvbnNvbGUubG9nKCdSdW5uaW5nIGluIHNlcnZlciBlbnZpcm9ubWVudCwgdXNpbmcgZGVmYXVsdCB0b2tlbicpO1xuICAgICAgdG9rZW4gPSAnJztcbiAgICB9XG4gICAgXG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gXG4gICAgfTtcbiAgICBcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9VUkx9L3N1YmplY3RBbmRHcmFkZS9zdWJqZWN0cy8ke3N1YmplY3RJZH1gLCB7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgaGVhZGVyc1xuICAgIH0pO1xuICAgIFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIHN1YmplY3QgZGV0YWlsczpgLCB7XG4gICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICBib2R5OiBlcnJvclRleHRcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciAke3Jlc3BvbnNlLnN0YXR1c306ICR7ZXJyb3JUZXh0fWApO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIHJldHVybiBkYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIHN1YmplY3QgZGV0YWlscyBmb3IgSUQgJHtzdWJqZWN0SWR9OmAsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFzc2lnbm1lbnQge1xuICBhc3NpZ25tZW50SWQ6IG51bWJlcjtcbiAgY2hpbGRJZDogbnVtYmVyO1xuICBjaGlsZE5hbWU/OiBzdHJpbmc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIGR1ZURhdGU6IHN0cmluZztcbiAgc3RhdHVzOiAncGVuZGluZycgfCAnc3VibWl0dGVkJyB8ICdncmFkZWQnIHwgJ2xhdGUnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZlZWRiYWNrIHtcbiAgZmVlZGJhY2tJZDogbnVtYmVyO1xuICBjaGlsZElkOiBudW1iZXI7XG4gIGNoaWxkTmFtZT86IHN0cmluZztcbiAgdGl0bGU6IHN0cmluZztcbiAgY29udGVudDogc3RyaW5nO1xuICBmZWVkYmFja1R5cGU6IHN0cmluZztcbiAgY3JlYXRlZEF0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3R1ZGVudCB7XG4gIGNoaWxkSWQ6IG51bWJlcjtcbiAgZmlyc3ROYW1lOiBzdHJpbmc7XG4gIGxhc3ROYW1lOiBzdHJpbmc7XG4gIHVzZXJuYW1lOiBzdHJpbmc7XG4gIHBob3RvOiBzdHJpbmcgfCBudWxsO1xuICBncmFkZUxldmVsSWQ6IG51bWJlciB8IG51bGw7XG4gIGdyYWRlTGV2ZWxOYW1lOiBzdHJpbmc7XG4gIHN1YmplY3RzOiBzdHJpbmdbXTtcbn1cblxuLyoqXG4gKiBUdXRvckRhc2hib2FyZFNlcnZpY2VcbiAqIEhhbmRsZXMgQVBJIGNhbGxzIHJlbGF0ZWQgdG8gdGhlIHR1dG9yIGRhc2hib2FyZFxuICovXG5leHBvcnQgY2xhc3MgVHV0b3JEYXNoYm9hcmRTZXJ2aWNlIHtcbiAgLyoqXG4gICAqIEdldCBhdXRoZW50aWNhdGlvbiBoZWFkZXJzXG4gICAqIEByZXR1cm5zIEhlYWRlcnMgb2JqZWN0IHdpdGggQXV0aG9yaXphdGlvbiB0b2tlblxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0QXV0aEhlYWRlcnMoKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gICAgLy8gVHJ5IG11bHRpcGxlIHBvc3NpYmxlIHRva2VuIGtleXMgdG8gaGFuZGxlIGluY29uc2lzdGVuY2llc1xuICAgIGxldCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0b2tlbicpIHx8IFxuICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FjY2Vzc1Rva2VuJykgfHwgXG4gICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCdhY2Nlc3NUb2tlbicpO1xuICAgIFxuICAgIC8vIEZpcnN0LCBjaGVjayBmb3IgZXhpc3RpbmcgdG9rZW4gd2l0aCBCZWFyZXIgcHJlZml4IChpbXBvcnRhbnQhKSAgICBcbiAgICBpZiAodG9rZW4gJiYgdG9rZW4uc3RhcnRzV2l0aCgnQmVhcmVyICcpKSB7XG4gICAgICAvLyBUb2tlbiBhbHJlYWR5IGhhcyBCZWFyZXIgcHJlZml4IC0gbGVhdmUgYXMgaXNcbiAgICAgIGNvbnNvbGUubG9nKCdUb2tlbiBhbHJlYWR5IGhhcyBCZWFyZXIgcHJlZml4Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENoZWNrIGlmIHRva2VuIGV4aXN0cyBhbmQgaXMgbm90IG1hbGZvcm1lZFxuICAgICAgaWYgKCF0b2tlbiB8fCB0b2tlbiA9PT0gJ3VuZGVmaW5lZCcgfHwgdG9rZW4gPT09ICdudWxsJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdBdXRoIHRva2VuIGlzIG1pc3Npbmcgb3IgaW52YWxpZCcpO1xuICAgICAgICAvLyBGb3Igbm93LCBmYWxsYmFjayB0byBlbXB0eSB0b2tlbiB0byBtYWtlIHRoZSBlcnJvciBtb3JlIG9idmlvdXMgaW4gQVBJIHJlc3BvbnNlc1xuICAgICAgICB0b2tlbiA9ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRW5zdXJlIHRva2VuIGlzIHByb3Blcmx5IHRyaW1tZWQgdG8gYXZvaWQgd2hpdGVzcGFjZSBpc3N1ZXNcbiAgICAgICAgdG9rZW4gPSB0b2tlbi50cmltKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTdG9yZSBvcmlnaW5hbCBmb3JtIGZvciBkaWFnbm9zdGljc1xuICAgICAgICBjb25zdCBvcmlnaW5hbFRva2VuTGVuZ3RoID0gdG9rZW4ubGVuZ3RoO1xuICAgICAgICBcbiAgICAgICAgLy8gQWRkIEJlYXJlciBwcmVmaXggb25seSBpZiBpdCdzIG5vdCBhbHJlYWR5IHRoZXJlXG4gICAgICAgIGlmICghdG9rZW4uc3RhcnRzV2l0aCgnQmVhcmVyICcpKSB7XG4gICAgICAgICAgdG9rZW4gPSBgQmVhcmVyICR7dG9rZW59YDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYFByb2Nlc3NlZCB0b2tlbjogb3JpZ2luYWwgbGVuZ3RoPSR7b3JpZ2luYWxUb2tlbkxlbmd0aH0sIG5ldyBsZW5ndGg9JHt0b2tlbi5sZW5ndGh9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFJldHVybiBoZWFkZXJzIHdpdGggQXV0aG9yaXphdGlvbiBpZiB0b2tlbiBleGlzdHNcbiAgICByZXR1cm4ge1xuICAgICAgQXV0aG9yaXphdGlvbjogdG9rZW4sIC8vIERvbid0IGFkZCBCZWFyZXIgcHJlZml4IGFnYWluIC0gaXQgc2hvdWxkIGFscmVhZHkgYmUgaW4gdGhlIHRva2VuXG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdHV0b3Igc3RhdHMgZm9yIGRhc2hib2FyZFxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggdHV0b3Igc3RhdHNcbiAgICovXG4gIHN0YXRpYyBhc3luYyBnZXRUdXRvclN0YXRzKCk6IFByb21pc2U8VHV0b3JTdGF0cz4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5nZXRBdXRoSGVhZGVycygpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoXG4gICAgICAgIGAke0FQSV9VUkx9L3VzZXJzL3R1dG9ycy9kYXNoYm9hcmQvc3RhdHNgLFxuICAgICAgICB7IGhlYWRlcnMgfVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHR1dG9yIHN0YXRzOicsIGVycm9yKTtcbiAgICAgIC8vIFJldHVybiBkZWZhdWx0IHN0YXRzIGlmIEFQSSBmYWlsc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmF0aW5nOiAwLFxuICAgICAgICByZXZpZXdzOiAwLFxuICAgICAgICB0b3RhbEVhcm5pbmdzOiAwLFxuICAgICAgICBtb250aGx5RWFybmluZ3M6IDAsXG4gICAgICAgIHVwY29taW5nU2Vzc2lvbnM6IDAsXG4gICAgICAgIHRvdGFsSG91cnM6IDAsXG4gICAgICAgIGNvbXBsZXRlZFNlc3Npb25zOiAwLFxuICAgICAgICBzdWJqZWN0czogW11cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB1cGNvbWluZyBzZXNzaW9ucyBmb3IgdGhlIHR1dG9yXG4gICAqIEBwYXJhbSBsaW1pdCBOdW1iZXIgb2Ygc2Vzc2lvbnMgdG8gcmV0dXJuXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBzZXNzaW9ucyBkYXRhXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZ2V0VXBjb21pbmdTZXNzaW9ucyhsaW1pdCA9IDUpOiBQcm9taXNlPFR1dG9yaW5nU2Vzc2lvbltdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmdldEF1dGhIZWFkZXJzKCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChcbiAgICAgICAgYCR7QVBJX1VSTH0vdHV0b3JzL3Nlc3Npb25zL215LXNlc3Npb25zYCxcbiAgICAgICAgeyBoZWFkZXJzIH1cbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIEZpbHRlciB0aGUgc2Vzc2lvbnMgYnkgc3RhdHVzIGFuZCBsaW1pdCB0aGUgcmVzdWx0cyBvbiB0aGUgY2xpZW50IHNpZGVcbiAgICAgIGNvbnN0IHVwY29taW5nU2Vzc2lvbnMgPSByZXNwb25zZS5kYXRhXG4gICAgICAgIC5maWx0ZXIoKHNlc3Npb246IFR1dG9yaW5nU2Vzc2lvbikgPT4gWydzY2hlZHVsZWQnLCAnY29uZmlybWVkJ10uaW5jbHVkZXMoc2Vzc2lvbi5zdGF0dXMpKVxuICAgICAgICAuc29ydCgoYTogVHV0b3JpbmdTZXNzaW9uLCBiOiBUdXRvcmluZ1Nlc3Npb24pID0+IG5ldyBEYXRlKGEuc3RhcnRUaW1lKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShiLnN0YXJ0VGltZSkuZ2V0VGltZSgpKVxuICAgICAgICAuc2xpY2UoMCwgbGltaXQpO1xuICAgICAgXG4gICAgICByZXR1cm4gdXBjb21pbmdTZXNzaW9ucztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgdXBjb21pbmcgc2Vzc2lvbnM6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcmVjZW50IGZlZWRiYWNrIHByb3ZpZGVkIGJ5IHRoZSB0dXRvclxuICAgKiBAcGFyYW0gbGltaXQgTnVtYmVyIG9mIGZlZWRiYWNrIGl0ZW1zIHRvIHJldHVyblxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggZmVlZGJhY2sgZGF0YVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGdldFJlY2VudEZlZWRiYWNrKGxpbWl0ID0gNSk6IFByb21pc2U8RmVlZGJhY2tbXT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5nZXRBdXRoSGVhZGVycygpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoXG4gICAgICAgIGAke0FQSV9VUkx9L3R1dG9ycy9mZWVkYmFjay9teS1mZWVkYmFja2AsXG4gICAgICAgIHsgaGVhZGVycyB9XG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBQcm9jZXNzIGFuZCBsaW1pdCB0aGUgZmVlZGJhY2sgZGF0YSBvbiB0aGUgY2xpZW50IHNpZGVcbiAgICAgIGNvbnN0IHJlY2VudEZlZWRiYWNrID0gcmVzcG9uc2UuZGF0YVxuICAgICAgICAuc29ydCgoYTogRmVlZGJhY2ssIGI6IEZlZWRiYWNrKSA9PiBuZXcgRGF0ZShiLmNyZWF0ZWRBdCkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYS5jcmVhdGVkQXQpLmdldFRpbWUoKSlcbiAgICAgICAgLnNsaWNlKDAsIGxpbWl0KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlY2VudEZlZWRiYWNrO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyByZWNlbnQgZmVlZGJhY2s6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYXNzaWdubWVudHMgY3JlYXRlZCBieSB0aGUgdHV0b3JcbiAgICogQHBhcmFtIGxpbWl0IE51bWJlciBvZiBhc3NpZ25tZW50cyB0byByZXR1cm5cbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIGFzc2lnbm1lbnRzIGRhdGFcbiAgICovXG4gIHN0YXRpYyBhc3luYyBnZXRSZWNlbnRBc3NpZ25tZW50cyhsaW1pdCA9IDUpOiBQcm9taXNlPEFzc2lnbm1lbnRbXT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5nZXRBdXRoSGVhZGVycygpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoXG4gICAgICAgIGAke0FQSV9VUkx9L3R1dG9ycy9hc3NpZ25tZW50cy9teS1hc3NpZ25tZW50c2AsXG4gICAgICAgIHsgaGVhZGVycyB9XG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBQcm9jZXNzIGFuZCBsaW1pdCB0aGUgYXNzaWdubWVudHMgZGF0YSBvbiB0aGUgY2xpZW50IHNpZGVcbiAgICAgIC8vIFNvcnQgYnkgZHVlIGRhdGUgd2l0aCBjbG9zZXN0IGR1ZSBkYXRlcyBmaXJzdFxuICAgICAgY29uc3QgcmVjZW50QXNzaWdubWVudHMgPSByZXNwb25zZS5kYXRhXG4gICAgICAgIC5zb3J0KChhOiBBc3NpZ25tZW50LCBiOiBBc3NpZ25tZW50KSA9PiBuZXcgRGF0ZShhLmR1ZURhdGUpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGIuZHVlRGF0ZSkuZ2V0VGltZSgpKVxuICAgICAgICAuc2xpY2UoMCwgbGltaXQpO1xuICAgICAgXG4gICAgICByZXR1cm4gcmVjZW50QXNzaWdubWVudHM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHJlY2VudCBhc3NpZ25tZW50czonLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFF1aWNrIGFzc2lnbiBob21ld29yayB0byBhIHN0dWRlbnRcbiAgICogQHBhcmFtIGFzc2lnbm1lbnREYXRhIE9iamVjdCBjb250YWluaW5nIGFzc2lnbm1lbnQgZGV0YWlsc1xuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggYXNzaWdubWVudCBjcmVhdGlvbiByZXN1bHRcbiAgICovXG4gIHN0YXRpYyBhc3luYyBxdWlja0Fzc2lnbkhvbWV3b3JrKGFzc2lnbm1lbnREYXRhOiB7XG4gICAgY2hpbGRJZDogbnVtYmVyO1xuICAgIHRpdGxlOiBzdHJpbmc7XG4gICAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgICBzdWJqZWN0SWQ6IG51bWJlcjtcbiAgICBkdWVEYXRlOiBzdHJpbmc7XG4gICAgbm90ZXM/OiBzdHJpbmc7XG4gIH0pIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuZ2V0QXV0aEhlYWRlcnMoKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MucG9zdChcbiAgICAgICAgYCR7QVBJX1VSTH0vdHV0b3JzL2Fzc2lnbm1lbnRzL3F1aWNrLWFzc2lnbmAsXG4gICAgICAgIGFzc2lnbm1lbnREYXRhLFxuICAgICAgICB7IGhlYWRlcnMgfVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHF1aWNrIGFzc2lnbm1lbnQ6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3cgcmVtb3ZlZCBhcyBpdCdzIGEgZHVwbGljYXRlIG9mIHRoZSBvbmUgYmVsb3dcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHR1dG9yaW5nIHNlc3Npb25cbiAgICogQHBhcmFtIHNlc3Npb25EYXRhIFRoZSBkYXRhIGZvciB0aGUgbmV3IHR1dG9yaW5nIHNlc3Npb25cbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHRoZSBjcmVhdGVkIHNlc3Npb24gZGF0YVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZVNlc3Npb24oc2Vzc2lvbkRhdGE6IGFueSk6IFByb21pc2U8YW55PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCB0b2tlbiBkaXJlY3RseSB0byBlbnN1cmUgd2UncmUgdXNpbmcgdGhlIGxhdGVzdCBmb3JtYXR0ZWQgdmVyc2lvblxuICAgICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9rZW4nKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FjY2Vzc1Rva2VuJykgfHwgXG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ2FjY2Vzc1Rva2VuJyk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgLy8gRm9ybWF0IHRva2VuIGlmIG5lZWRlZFxuICAgICAgY29uc3QgZm9ybWF0dGVkVG9rZW4gPSB0b2tlbiAmJiAhdG9rZW4uc3RhcnRzV2l0aCgnQmVhcmVyICcpID8gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBgQmVhcmVyICR7dG9rZW4udHJpbSgpfWAgOiB0b2tlbjtcbiAgICAgIFxuICAgICAgLy8gVXNlIHRoZSBmb3JtYXR0ZWQgdG9rZW4gZGlyZWN0bHlcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgIEF1dGhvcml6YXRpb246IGZvcm1hdHRlZFRva2VuLFxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgc2Vzc2lvbiB3aXRoIGhlYWRlcnM6Jywge1xuICAgICAgICBhdXRoSGVhZGVyTGVuZ3RoOiBoZWFkZXJzLkF1dGhvcml6YXRpb24/Lmxlbmd0aCB8fCAwLFxuICAgICAgICBoYXNCZWFyZXJQcmVmaXg6IGhlYWRlcnMuQXV0aG9yaXphdGlvbj8uc3RhcnRzV2l0aCgnQmVhcmVyICcpIHx8IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIHNlc3Npb24gd2l0aCBkYXRhOicsIHtcbiAgICAgICAgLi4uc2Vzc2lvbkRhdGEsXG4gICAgICAgIGNoaWxkSWQ6IE51bWJlcihzZXNzaW9uRGF0YS5jaGlsZElkKSxcbiAgICAgICAgc3ViamVjdElkOiBOdW1iZXIoc2Vzc2lvbkRhdGEuc3ViamVjdElkKSAgXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gTWFrZSBkaXJlY3QgQVBJIGNhbGwgd2l0aCB0aGUgZm9ybWF0dGVkIGhlYWRlclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5wb3N0KFxuICAgICAgICBgJHtBUElfVVJMfS90dXRvcnMvc2Vzc2lvbnNgLFxuICAgICAgICB7XG4gICAgICAgICAgLi4uc2Vzc2lvbkRhdGEsXG4gICAgICAgICAgY2hpbGRJZDogTnVtYmVyKHNlc3Npb25EYXRhLmNoaWxkSWQpLFxuICAgICAgICAgIHN1YmplY3RJZDogTnVtYmVyKHNlc3Npb25EYXRhLnN1YmplY3RJZCksXG4gICAgICAgICAgLy8gQWRkIGR1cmF0aW9uTWludXRlcyBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgZHVyYXRpb25NaW51dGVzOiBzZXNzaW9uRGF0YS5kdXJhdGlvbk1pbnV0ZXMgfHwgXG4gICAgICAgICAgICAoc2Vzc2lvbkRhdGEuc3RhcnRUaW1lICYmIHNlc3Npb25EYXRhLmVuZFRpbWUgPyBcbiAgICAgICAgICAgIE1hdGgucm91bmQoKG5ldyBEYXRlKHNlc3Npb25EYXRhLmVuZFRpbWUpLmdldFRpbWUoKSAtIG5ldyBEYXRlKHNlc3Npb25EYXRhLnN0YXJ0VGltZSkuZ2V0VGltZSgpKSAvIDYwMDAwKSA6IDYwKVxuICAgICAgICB9LFxuICAgICAgICB7IGhlYWRlcnMgfVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ1Nlc3Npb24gY3JlYXRlZCBzdWNjZXNzZnVsbHk6JywgcmVzcG9uc2UuZGF0YSk7XG4gICAgICBcbiAgICAgIC8vIFN0b3JlIHRoZSB0b2tlbiB3aXRoIEJlYXJlciBwcmVmaXggZm9yIGZ1dHVyZSB1c2VcbiAgICAgIGlmIChmb3JtYXR0ZWRUb2tlbikge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgndG9rZW4nLCBmb3JtYXR0ZWRUb2tlbik7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhY2Nlc3NUb2tlbicsIGZvcm1hdHRlZFRva2VuKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgc2Vzc2lvbjonLCBlcnJvcik7XG4gICAgICBpZiAoZXJyb3IucmVzcG9uc2UpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVzcG9uc2UgZGF0YTonLCBlcnJvci5yZXNwb25zZS5kYXRhKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVzcG9uc2Ugc3RhdHVzOicsIGVycm9yLnJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGNvbXBsZXRlZCBzZXNzaW9ucyBmb3IgdGhlIHR1dG9yXG4gICAqIEBwYXJhbSBsaW1pdCBOdW1iZXIgb2Ygc2Vzc2lvbnMgdG8gcmV0dXJuXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBzZXNzaW9ucyBkYXRhXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZ2V0Q29tcGxldGVkU2Vzc2lvbnMobGltaXQgPSA1KTogUHJvbWlzZTxUdXRvcmluZ1Nlc3Npb25bXT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5nZXRBdXRoSGVhZGVycygpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoXG4gICAgICAgIGAke0FQSV9VUkx9L3R1dG9ycy9zZXNzaW9ucy9teS1zZXNzaW9uc2AsXG4gICAgICAgIHsgaGVhZGVycyB9XG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBGaWx0ZXIgdG8gb25seSBpbmNsdWRlIGNvbXBsZXRlZCBzZXNzaW9ucyBhbmQgc29ydCBieSBtb3N0IHJlY2VudCBmaXJzdFxuICAgICAgY29uc3QgY29tcGxldGVkU2Vzc2lvbnMgPSByZXNwb25zZS5kYXRhXG4gICAgICAgIC5maWx0ZXIoKHNlc3Npb246IFR1dG9yaW5nU2Vzc2lvbikgPT4gc2Vzc2lvbi5zdGF0dXMgPT09ICdjb21wbGV0ZWQnKVxuICAgICAgICAuc29ydCgoYTogVHV0b3JpbmdTZXNzaW9uLCBiOiBUdXRvcmluZ1Nlc3Npb24pID0+IG5ldyBEYXRlKGIuZW5kVGltZSkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYS5lbmRUaW1lKS5nZXRUaW1lKCkpXG4gICAgICAgIC5zbGljZSgwLCBsaW1pdCk7XG4gICAgICBcbiAgICAgIHJldHVybiBjb21wbGV0ZWRTZXNzaW9ucztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgY29tcGxldGVkIHNlc3Npb25zOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHR1dG9yIHN0YXRpc3RpY3MgYmFzZWQgb24gYWxsIGF2YWlsYWJsZSBkYXRhXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBjYWxjdWxhdGVkIHN0YXRpc3RpY3NcbiAgICovXG4gIHN0YXRpYyBhc3luYyBjYWxjdWxhdGVUdXRvclN0YXRzKCk6IFByb21pc2U8VHV0b3JTdGF0cz4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgYWxsIHNlc3Npb25zIHRvIGNhbGN1bGF0ZSBzdGF0c1xuICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuZ2V0QXV0aEhlYWRlcnMoKTtcbiAgICAgIGNvbnN0IHNlc3Npb25zUmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoYCR7QVBJX1VSTH0vdHV0b3JzL3Nlc3Npb25zL215LXNlc3Npb25zYCwgeyBoZWFkZXJzIH0pO1xuICAgICAgY29uc3QgYWxsU2Vzc2lvbnMgPSBzZXNzaW9uc1Jlc3BvbnNlLmRhdGEgYXMgVHV0b3JpbmdTZXNzaW9uW107XG4gICAgICBcbiAgICAgIC8vIEdldCB0dXRvcidzIHByb2ZpbGVcbiAgICAgIGNvbnN0IHByb2ZpbGVSZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChgJHtBUElfVVJMfS91c2Vycy90dXRvcnMvcHJvZmlsZS9tZWAsIHsgaGVhZGVycyB9KTtcbiAgICAgIGNvbnN0IHByb2ZpbGUgPSBwcm9maWxlUmVzcG9uc2UuZGF0YTtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIHN0YXRzIGZyb20gc2Vzc2lvbnMgZGF0YVxuICAgICAgY29uc3QgY29tcGxldGVkU2Vzc2lvbnMgPSBhbGxTZXNzaW9ucy5maWx0ZXIoc2Vzc2lvbiA9PiBzZXNzaW9uLnN0YXR1cyA9PT0gJ2NvbXBsZXRlZCcpO1xuICAgICAgY29uc3QgdXBjb21pbmdTZXNzaW9ucyA9IGFsbFNlc3Npb25zLmZpbHRlcihzZXNzaW9uID0+IFsnc2NoZWR1bGVkJywgJ2NvbmZpcm1lZCddLmluY2x1ZGVzKHNlc3Npb24uc3RhdHVzKSk7XG4gICAgICBjb25zdCB0b3RhbEhvdXJzID0gY29tcGxldGVkU2Vzc2lvbnMucmVkdWNlKCh0b3RhbCwgc2Vzc2lvbikgPT4ge1xuICAgICAgICBjb25zdCBzdGFydCA9IG5ldyBEYXRlKHNlc3Npb24uc3RhcnRUaW1lKS5nZXRUaW1lKCk7XG4gICAgICAgIGNvbnN0IGVuZCA9IG5ldyBEYXRlKHNlc3Npb24uZW5kVGltZSkuZ2V0VGltZSgpO1xuICAgICAgICBjb25zdCBob3VycyA9IChlbmQgLSBzdGFydCkgLyAoMTAwMCAqIDYwICogNjApOyAvLyBDb252ZXJ0IG1pbGxpc2Vjb25kcyB0byBob3Vyc1xuICAgICAgICByZXR1cm4gdG90YWwgKyBob3VycztcbiAgICAgIH0sIDApO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgbW9udGhseSBlYXJuaW5ncyAoYXNzdW1pbmcgc2Vzc2lvbnMgaGF2ZSBhIHByaWNlIGZpZWxkIG9yIHVzaW5nIGEgZGVmYXVsdCByYXRlKVxuICAgICAgY29uc3QgY3VycmVudE1vbnRoID0gbmV3IERhdGUoKS5nZXRNb250aCgpO1xuICAgICAgY29uc3QgY3VycmVudFllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG4gICAgICBjb25zdCB0aGlzTW9udGhDb21wbGV0ZWRTZXNzaW9ucyA9IGNvbXBsZXRlZFNlc3Npb25zLmZpbHRlcihzZXNzaW9uID0+IHtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbkRhdGUgPSBuZXcgRGF0ZShzZXNzaW9uLmVuZFRpbWUpO1xuICAgICAgICByZXR1cm4gc2Vzc2lvbkRhdGUuZ2V0TW9udGgoKSA9PT0gY3VycmVudE1vbnRoICYmIHNlc3Npb25EYXRlLmdldEZ1bGxZZWFyKCkgPT09IGN1cnJlbnRZZWFyO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIEFzc3VtaW5nIGFuIGF2ZXJhZ2UgcmF0ZSBvZiAkNDAvaG91ciBmb3IgY2FsY3VsYXRpb25cbiAgICAgIGNvbnN0IGhvdXJseVJhdGUgPSA0MDtcbiAgICAgIGNvbnN0IG1vbnRobHlFYXJuaW5ncyA9IHRoaXNNb250aENvbXBsZXRlZFNlc3Npb25zLnJlZHVjZSgodG90YWwsIHNlc3Npb24pID0+IHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBuZXcgRGF0ZShzZXNzaW9uLnN0YXJ0VGltZSkuZ2V0VGltZSgpO1xuICAgICAgICBjb25zdCBlbmQgPSBuZXcgRGF0ZShzZXNzaW9uLmVuZFRpbWUpLmdldFRpbWUoKTtcbiAgICAgICAgY29uc3QgaG91cnMgPSAoZW5kIC0gc3RhcnQpIC8gKDEwMDAgKiA2MCAqIDYwKTtcbiAgICAgICAgcmV0dXJuIHRvdGFsICsgKGhvdXJzICogaG91cmx5UmF0ZSk7XG4gICAgICB9LCAwKTtcbiAgICAgIFxuICAgICAgY29uc3QgdG90YWxFYXJuaW5ncyA9IGNvbXBsZXRlZFNlc3Npb25zLnJlZHVjZSgodG90YWwsIHNlc3Npb24pID0+IHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBuZXcgRGF0ZShzZXNzaW9uLnN0YXJ0VGltZSkuZ2V0VGltZSgpO1xuICAgICAgICBjb25zdCBlbmQgPSBuZXcgRGF0ZShzZXNzaW9uLmVuZFRpbWUpLmdldFRpbWUoKTtcbiAgICAgICAgY29uc3QgaG91cnMgPSAoZW5kIC0gc3RhcnQpIC8gKDEwMDAgKiA2MCAqIDYwKTtcbiAgICAgICAgcmV0dXJuIHRvdGFsICsgKGhvdXJzICogaG91cmx5UmF0ZSk7XG4gICAgICB9LCAwKTtcbiAgICAgIFxuICAgICAgLy8gUmV0dXJuIGNhbGN1bGF0ZWQgc3RhdGlzdGljc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmF0aW5nOiA0LjUsIC8vIFBsYWNlaG9sZGVyIHJhdGluZ1xuICAgICAgICByZXZpZXdzOiBjb21wbGV0ZWRTZXNzaW9ucy5sZW5ndGgsIC8vIEFzc3VtaW5nIDEgcmV2aWV3IHBlciBjb21wbGV0ZWQgc2Vzc2lvblxuICAgICAgICB0b3RhbEVhcm5pbmdzOiBNYXRoLnJvdW5kKHRvdGFsRWFybmluZ3MpLFxuICAgICAgICBtb250aGx5RWFybmluZ3M6IE1hdGgucm91bmQobW9udGhseUVhcm5pbmdzKSxcbiAgICAgICAgdXBjb21pbmdTZXNzaW9uczogdXBjb21pbmdTZXNzaW9ucy5sZW5ndGgsXG4gICAgICAgIHRvdGFsSG91cnM6IE1hdGgucm91bmQodG90YWxIb3VycyAqIDEwKSAvIDEwLCAvLyBSb3VuZCB0byAxIGRlY2ltYWwgcGxhY2VcbiAgICAgICAgY29tcGxldGVkU2Vzc2lvbnM6IGNvbXBsZXRlZFNlc3Npb25zLmxlbmd0aCxcbiAgICAgICAgc3ViamVjdHM6IFsnTWF0aCcsICdTY2llbmNlJywgJ0VuZ2xpc2gnXSAvLyBQbGFjZWhvbGRlciBzdWJqZWN0c1xuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2FsY3VsYXRpbmcgdHV0b3Igc3RhdHM6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmF0aW5nOiAwLFxuICAgICAgICByZXZpZXdzOiAwLFxuICAgICAgICB0b3RhbEVhcm5pbmdzOiAwLFxuICAgICAgICBtb250aGx5RWFybmluZ3M6IDAsXG4gICAgICAgIHVwY29taW5nU2Vzc2lvbnM6IDAsXG4gICAgICAgIHRvdGFsSG91cnM6IDAsXG4gICAgICAgIGNvbXBsZXRlZFNlc3Npb25zOiAwLFxuICAgICAgICBzdWJqZWN0czogW11cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoZXMgdGhlIGxpc3Qgb2Ygc3R1ZGVudHMgdGhhdCB0aGUgdHV0b3IgY2FuIGNyZWF0ZSBzZXNzaW9ucyBhbmQgYXNzaWdubWVudHMgd2l0aFxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggYXJyYXkgb2Ygc3R1ZGVudCBkYXRhXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZ2V0QXZhaWxhYmxlU3R1ZGVudHMoKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5nZXRBdXRoSGVhZGVycygpO1xuICAgICAgXG4gICAgICAvLyBBZGQgY2FjaGUtYnVzdGluZyBxdWVyeSBwYXJhbWV0ZXJcbiAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChcbiAgICAgICAgYCR7QVBJX1VSTH0vdXNlcnMvY2hpbGRyZW4vdHV0b3JpbmcvYXZhaWxhYmxlLXN0dWRlbnRzP189JHt0aW1lc3RhbXB9YCwgXG4gICAgICAgIHsgXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgICAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlLCBuby1zdG9yZScsXG4gICAgICAgICAgICAnUHJhZ21hJzogJ25vLWNhY2hlJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ0F2YWlsYWJsZSBzdHVkZW50cyByZXNwb25zZTonLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLmRhdGEpO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEgfHwgW107XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkgeyAvLyBUeXBlIGFzc2VydGlvbiBmb3IgZXJyb3IgaGFuZGxpbmdcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGF2YWlsYWJsZSBzdHVkZW50czonLCBlcnJvcik7XG4gICAgICBjb25zb2xlLmxvZygnRXJyb3IgZGV0YWlsczonLCBlcnJvci5yZXNwb25zZT8uZGF0YSB8fCBlcnJvci5tZXNzYWdlKTtcbiAgICAgIC8vIFJldHVybiBlbXB0eSBhcnJheSBvbiBlcnJvclxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgYSBzZXNzaW9uJ3Mgc3RhdHVzXG4gICAqIEBwYXJhbSBzZXNzaW9uSWQgVGhlIElEIG9mIHRoZSBzZXNzaW9uIHRvIHVwZGF0ZVxuICAgKiBAcGFyYW0gc3RhdHVzIFRoZSBuZXcgc3RhdHVzIHRvIHNldFxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggdGhlIHVwZGF0ZWQgc2Vzc2lvbiBkYXRhXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgdXBkYXRlU2Vzc2lvblN0YXR1cyhzZXNzaW9uSWQ6IG51bWJlciwgc3RhdHVzOiBzdHJpbmcpOiBQcm9taXNlPFR1dG9yaW5nU2Vzc2lvbj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5nZXRBdXRoSGVhZGVycygpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5wYXRjaChcbiAgICAgICAgYCR7QVBJX1VSTH0vdHV0b3JzL3Nlc3Npb25zLyR7c2Vzc2lvbklkfS9zdGF0dXNgLFxuICAgICAgICB7IHN0YXR1cyB9LFxuICAgICAgICB7IGhlYWRlcnMgfVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHVwZGF0aW5nIHNlc3Npb24gJHtzZXNzaW9uSWR9IHN0YXR1czpgLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjsgLy8gUmV0aHJvdyB0byBsZXQgdGhlIGNvbXBvbmVudCBoYW5kbGUgdGhlIGVycm9yXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsiYXhpb3MiLCJBUElfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJpc0NsaWVudCIsImZldGNoQ2hpbGREZXRhaWxzIiwiY2hpbGRJZCIsInRva2VuIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJsb2ciLCJoZWFkZXJzIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsIm9rIiwiZXJyb3JUZXh0IiwidGV4dCIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJib2R5IiwiRXJyb3IiLCJkYXRhIiwianNvbiIsImZldGNoU3ViamVjdERldGFpbHMiLCJzdWJqZWN0SWQiLCJUdXRvckRhc2hib2FyZFNlcnZpY2UiLCJnZXRBdXRoSGVhZGVycyIsInNlc3Npb25TdG9yYWdlIiwic3RhcnRzV2l0aCIsInRyaW0iLCJvcmlnaW5hbFRva2VuTGVuZ3RoIiwibGVuZ3RoIiwiQXV0aG9yaXphdGlvbiIsImdldFR1dG9yU3RhdHMiLCJnZXQiLCJyYXRpbmciLCJyZXZpZXdzIiwidG90YWxFYXJuaW5ncyIsIm1vbnRobHlFYXJuaW5ncyIsInVwY29taW5nU2Vzc2lvbnMiLCJ0b3RhbEhvdXJzIiwiY29tcGxldGVkU2Vzc2lvbnMiLCJzdWJqZWN0cyIsImdldFVwY29taW5nU2Vzc2lvbnMiLCJsaW1pdCIsImZpbHRlciIsInNlc3Npb24iLCJpbmNsdWRlcyIsInNvcnQiLCJhIiwiYiIsIkRhdGUiLCJzdGFydFRpbWUiLCJnZXRUaW1lIiwic2xpY2UiLCJnZXRSZWNlbnRGZWVkYmFjayIsInJlY2VudEZlZWRiYWNrIiwiY3JlYXRlZEF0IiwiZ2V0UmVjZW50QXNzaWdubWVudHMiLCJyZWNlbnRBc3NpZ25tZW50cyIsImR1ZURhdGUiLCJxdWlja0Fzc2lnbkhvbWV3b3JrIiwiYXNzaWdubWVudERhdGEiLCJwb3N0IiwiY3JlYXRlU2Vzc2lvbiIsInNlc3Npb25EYXRhIiwiZm9ybWF0dGVkVG9rZW4iLCJhdXRoSGVhZGVyTGVuZ3RoIiwiaGFzQmVhcmVyUHJlZml4IiwiTnVtYmVyIiwiZHVyYXRpb25NaW51dGVzIiwiZW5kVGltZSIsIk1hdGgiLCJyb3VuZCIsInNldEl0ZW0iLCJnZXRDb21wbGV0ZWRTZXNzaW9ucyIsImNhbGN1bGF0ZVR1dG9yU3RhdHMiLCJzZXNzaW9uc1Jlc3BvbnNlIiwiYWxsU2Vzc2lvbnMiLCJwcm9maWxlUmVzcG9uc2UiLCJwcm9maWxlIiwicmVkdWNlIiwidG90YWwiLCJzdGFydCIsImVuZCIsImhvdXJzIiwiY3VycmVudE1vbnRoIiwiZ2V0TW9udGgiLCJjdXJyZW50WWVhciIsImdldEZ1bGxZZWFyIiwidGhpc01vbnRoQ29tcGxldGVkU2Vzc2lvbnMiLCJzZXNzaW9uRGF0ZSIsImhvdXJseVJhdGUiLCJnZXRBdmFpbGFibGVTdHVkZW50cyIsInRpbWVzdGFtcCIsIm1lc3NhZ2UiLCJ1cGRhdGVTZXNzaW9uU3RhdHVzIiwic2Vzc2lvbklkIiwicGF0Y2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/tutor-dashboard.service.ts\n"));

/***/ })

});