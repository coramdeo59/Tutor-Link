"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(dashboard)/tutor-dashboard/page",{

/***/ "(app-pages-browser)/./src/services/tutor-dashboard.service.ts":
/*!*************************************************!*\
  !*** ./src/services/tutor-dashboard.service.ts ***!
  \*************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TutorDashboardService: function() { return /* binding */ TutorDashboardService; },\n/* harmony export */   fetchChildDetails: function() { return /* binding */ fetchChildDetails; },\n/* harmony export */   fetchSubjectDetails: function() { return /* binding */ fetchSubjectDetails; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/.pnpm/axios@1.9.0/node_modules/axios/lib/axios.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.28_@babel+core@7.27.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/build/polyfills/process.js\");\n\"use clinet\";\n\nconst API_URL = process.env.NEXT_PUBLIC_API_URL || \"http://localhost:3001\";\n// Safely check if window is defined (client-side only)\nconst isClient = \"object\" !== \"undefined\";\n// Fetches child details from the backend by ID\nconst fetchChildDetails = async (childId)=>{\n    try {\n        // Get token from localStorage - only in client environment\n        let token;\n        if (isClient) {\n            try {\n                token = localStorage.getItem(\"accessToken\");\n            } catch (e) {\n                console.error(\"Error accessing localStorage:\", e);\n                return null;\n            }\n        } else {\n            // Server-side fallback (Next.js SSR)\n            console.log(\"Running in server environment, using default token\");\n            token = \"\";\n        }\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": \"Bearer \".concat(token)\n        };\n        const response = await fetch(\"\".concat(API_URL, \"/users/children/tutoring/child/\").concat(childId), {\n            method: \"GET\",\n            headers\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            console.error(\"Error fetching child details:\", {\n                status: response.status,\n                statusText: response.statusText,\n                body: errorText\n            });\n            throw new Error(\"Error \".concat(response.status, \": \").concat(errorText));\n        }\n        const data = await response.json();\n        return data;\n    } catch (error) {\n        console.error(\"Error fetching child details for ID \".concat(childId, \":\"), error);\n        return null;\n    }\n};\n// Fetches subject details from the backend by ID\nconst fetchSubjectDetails = async (subjectId)=>{\n    try {\n        // Get token from localStorage - only in client environment\n        let token;\n        if (isClient) {\n            try {\n                token = localStorage.getItem(\"accessToken\");\n            } catch (e) {\n                console.error(\"Error accessing localStorage:\", e);\n                return null;\n            }\n        } else {\n            // Server-side fallback (Next.js SSR)\n            console.log(\"Running in server environment, using default token\");\n            token = \"\";\n        }\n        const headers = {\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": \"Bearer \".concat(token)\n        };\n        const response = await fetch(\"\".concat(API_URL, \"/subjectAndGrade/subjects/\").concat(subjectId), {\n            method: \"GET\",\n            headers\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            console.error(\"Error fetching subject details:\", {\n                status: response.status,\n                statusText: response.statusText,\n                body: errorText\n            });\n            throw new Error(\"Error \".concat(response.status, \": \").concat(errorText));\n        }\n        const data = await response.json();\n        return data;\n    } catch (error) {\n        console.error(\"Error fetching subject details for ID \".concat(subjectId, \":\"), error);\n        return null;\n    }\n};\n/**\n * TutorDashboardService\n * Handles API calls related to the tutor dashboard\n */ class TutorDashboardService {\n    /**\n   * Get authentication headers\n   * @returns Headers object with Authorization token\n   */ static getAuthHeaders() {\n        // Try multiple possible token keys to handle inconsistencies\n        let token = localStorage.getItem(\"token\") || localStorage.getItem(\"accessToken\") || sessionStorage.getItem(\"accessToken\");\n        // First, check for existing token with Bearer prefix (important!)    \n        if (token && token.startsWith(\"Bearer \")) {\n            // Token already has Bearer prefix - leave as is\n            console.log(\"Token already has Bearer prefix\");\n        } else {\n            // Check if token exists and is not malformed\n            if (!token || token === \"undefined\" || token === \"null\") {\n                console.error(\"Auth token is missing or invalid\");\n                // For now, fallback to empty token to make the error more obvious in API responses\n                token = \"\";\n            } else {\n                // Ensure token is properly trimmed to avoid whitespace issues\n                token = token.trim();\n                // Store original form for diagnostics\n                const originalTokenLength = token.length;\n                // Add Bearer prefix only if it's not already there\n                if (!token.startsWith(\"Bearer \")) {\n                    token = \"Bearer \".concat(token);\n                }\n                console.log(\"Processed token: original length=\".concat(originalTokenLength, \", new length=\").concat(token.length));\n            }\n        }\n        // Return headers with Authorization if token exists\n        return {\n            Authorization: token,\n            \"Content-Type\": \"application/json\"\n        };\n    }\n    /**\n   * Get tutor stats for dashboard\n   * @returns Promise with tutor stats\n   */ static async getTutorStats() {\n        try {\n            const headers = this.getAuthHeaders();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/users/tutors/dashboard/stats\"), {\n                headers\n            });\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching tutor stats:\", error);\n            // Return default stats if API fails\n            return {\n                rating: 0,\n                reviews: 0,\n                totalEarnings: 0,\n                monthlyEarnings: 0,\n                upcomingSessions: 0,\n                totalHours: 0,\n                completedSessions: 0,\n                subjects: []\n            };\n        }\n    }\n    /**\n   * Get upcoming sessions for the tutor\n   * @param limit Number of sessions to return\n   * @returns Promise with sessions data\n   */ static async getUpcomingSessions() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5;\n        try {\n            const headers = this.getAuthHeaders();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/tutors/sessions/my-sessions\"), {\n                headers\n            });\n            // Filter the sessions by status and limit the results on the client side\n            const upcomingSessions = response.data.filter((session)=>[\n                    \"scheduled\",\n                    \"confirmed\"\n                ].includes(session.status)).sort((a, b)=>new Date(a.startTime).getTime() - new Date(b.startTime).getTime()).slice(0, limit);\n            return upcomingSessions;\n        } catch (error) {\n            console.error(\"Error fetching upcoming sessions:\", error);\n            return [];\n        }\n    }\n    /**\n   * Get recent feedback provided by the tutor\n   * @param limit Number of feedback items to return\n   * @returns Promise with feedback data\n   */ static async getRecentFeedback() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5;\n        try {\n            const headers = this.getAuthHeaders();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/tutors/feedback/my-feedback\"), {\n                headers\n            });\n            // Process and limit the feedback data on the client side\n            const recentFeedback = response.data.sort((a, b)=>new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()).slice(0, limit);\n            return recentFeedback;\n        } catch (error) {\n            console.error(\"Error fetching recent feedback:\", error);\n            return [];\n        }\n    }\n    /**\n   * Get assignments created by the tutor\n   * @param limit Number of assignments to return\n   * @returns Promise with assignments data\n   */ static async getRecentAssignments() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5;\n        try {\n            const headers = this.getAuthHeaders();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/tutors/assignments/my-assignments\"), {\n                headers\n            });\n            // Process and limit the assignments data on the client side\n            // Sort by due date with closest due dates first\n            const recentAssignments = response.data.sort((a, b)=>new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime()).slice(0, limit);\n            return recentAssignments;\n        } catch (error) {\n            console.error(\"Error fetching recent assignments:\", error);\n            return [];\n        }\n    }\n    /**\n   * Get available students for tutoring sessions\n   * @returns Promise with available students data\n   */ static async getAvailableStudents() {\n        try {\n            const headers = this.getAuthHeaders();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/users/children/tutoring/available-students\"), {\n                headers\n            });\n            // Return the students data directly from the API\n            return response.data || [];\n        } catch (error) {\n            console.error(\"Error fetching available students:\", error);\n            return [];\n        }\n    }\n    /**\n   * Create a new tutoring session\n   * @param sessionData The data for the new tutoring session\n   * @returns Promise with the created session data\n   */ static async createSession(sessionData) {\n        try {\n            const headers = this.getAuthHeaders();\n            console.log(\"Creating session with data:\", sessionData);\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(\"\".concat(API_URL, \"/tutors/sessions\"), {\n                ...sessionData,\n                childId: Number(sessionData.childId),\n                subjectId: Number(sessionData.subjectId)\n            }, {\n                headers\n            });\n            console.log(\"Session created successfully:\", response.data);\n            return response.data;\n        } catch (error) {\n            console.error(\"Error creating session:\", error);\n            if (error.response) {\n                console.error(\"Error response data:\", error.response.data);\n                console.error(\"Error response status:\", error.response.status);\n            }\n            throw error;\n        }\n    }\n    /**\n   * Get completed sessions for the tutor\n   * @param limit Number of sessions to return\n   * @returns Promise with sessions data\n   */ static async getCompletedSessions() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5;\n        try {\n            const headers = this.getAuthHeaders();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/tutors/sessions/my-sessions\"), {\n                headers\n            });\n            // Filter to only include completed sessions and sort by most recent first\n            const completedSessions = response.data.filter((session)=>session.status === \"completed\").sort((a, b)=>new Date(b.endTime).getTime() - new Date(a.endTime).getTime()).slice(0, limit);\n            return completedSessions;\n        } catch (error) {\n            console.error(\"Error fetching completed sessions:\", error);\n            return [];\n        }\n    }\n    /**\n   * Calculate tutor statistics based on all available data\n   * @returns Promise with calculated statistics\n   */ static async calculateTutorStats() {\n        try {\n            // Get all sessions to calculate stats\n            const headers = this.getAuthHeaders();\n            const sessionsResponse = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/tutors/sessions/my-sessions\"), {\n                headers\n            });\n            const allSessions = sessionsResponse.data;\n            // Get tutor's profile\n            const profileResponse = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/users/tutors/profile/me\"), {\n                headers\n            });\n            const profile = profileResponse.data;\n            // Calculate stats from sessions data\n            const completedSessions = allSessions.filter((session)=>session.status === \"completed\");\n            const upcomingSessions = allSessions.filter((session)=>[\n                    \"scheduled\",\n                    \"confirmed\"\n                ].includes(session.status));\n            const totalHours = completedSessions.reduce((total, session)=>{\n                const start = new Date(session.startTime).getTime();\n                const end = new Date(session.endTime).getTime();\n                const hours = (end - start) / (1000 * 60 * 60); // Convert milliseconds to hours\n                return total + hours;\n            }, 0);\n            // Calculate monthly earnings (assuming sessions have a price field or using a default rate)\n            const currentMonth = new Date().getMonth();\n            const currentYear = new Date().getFullYear();\n            const thisMonthCompletedSessions = completedSessions.filter((session)=>{\n                const sessionDate = new Date(session.endTime);\n                return sessionDate.getMonth() === currentMonth && sessionDate.getFullYear() === currentYear;\n            });\n            // Assuming an average rate of $40/hour for calculation\n            const hourlyRate = 40;\n            const monthlyEarnings = thisMonthCompletedSessions.reduce((total, session)=>{\n                const start = new Date(session.startTime).getTime();\n                const end = new Date(session.endTime).getTime();\n                const hours = (end - start) / (1000 * 60 * 60);\n                return total + hours * hourlyRate;\n            }, 0);\n            const totalEarnings = completedSessions.reduce((total, session)=>{\n                const start = new Date(session.startTime).getTime();\n                const end = new Date(session.endTime).getTime();\n                const hours = (end - start) / (1000 * 60 * 60);\n                return total + hours * hourlyRate;\n            }, 0);\n            // Return calculated statistics\n            return {\n                rating: 4.5,\n                reviews: completedSessions.length,\n                totalEarnings: Math.round(totalEarnings),\n                monthlyEarnings: Math.round(monthlyEarnings),\n                upcomingSessions: upcomingSessions.length,\n                totalHours: Math.round(totalHours * 10) / 10,\n                completedSessions: completedSessions.length,\n                subjects: [\n                    \"Math\",\n                    \"Science\",\n                    \"English\"\n                ] // Placeholder subjects\n            };\n        } catch (error) {\n            console.error(\"Error calculating tutor stats:\", error);\n            return {\n                rating: 0,\n                reviews: 0,\n                totalEarnings: 0,\n                monthlyEarnings: 0,\n                upcomingSessions: 0,\n                totalHours: 0,\n                completedSessions: 0,\n                subjects: []\n            };\n        }\n    }\n    /**\n   * Get available students for tutoring sessions\n   * Fetches the list of students that the tutor can create sessions with\n   * @returns Promise with array of student data\n   */ static async getAvailableStudents() {\n        try {\n            const headers = this.getAuthHeaders();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/users/children/tutoring/available-students\"), {\n                headers\n            });\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching available students:\", error);\n            // Return empty array on error\n            return [];\n        }\n    }\n    /**\n   * Update a session's status\n   * @param sessionId The ID of the session to update\n   * @param status The new status to set\n   * @returns Promise with the updated session data\n   */ static async updateSessionStatus(sessionId, status) {\n        try {\n            const headers = this.getAuthHeaders();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].patch(\"\".concat(API_URL, \"/tutors/sessions/\").concat(sessionId, \"/status\"), {\n                status\n            }, {\n                headers\n            });\n            return response.data;\n        } catch (error) {\n            console.error(\"Error updating session \".concat(sessionId, \" status:\"), error);\n            throw error; // Rethrow to let the component handle the error\n        }\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy90dXRvci1kYXNoYm9hcmQuc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQzBCO0FBRTFCLE1BQU1DLFVBQVVDLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsbUJBQW1CLElBQUk7QUE4Q25ELHVEQUF1RDtBQUN2RCxNQUFNQyxXQUFXLGFBQWtCO0FBRW5DLCtDQUErQztBQUN4QyxNQUFNQyxvQkFBb0IsT0FBT0M7SUFDdEMsSUFBSTtRQUNGLDJEQUEyRDtRQUMzRCxJQUFJQztRQUNKLElBQUlILFVBQVU7WUFDWixJQUFJO2dCQUNGRyxRQUFRQyxhQUFhQyxPQUFPLENBQUM7WUFDL0IsRUFBRSxPQUFPQyxHQUFHO2dCQUNWQyxRQUFRQyxLQUFLLENBQUMsaUNBQWlDRjtnQkFDL0MsT0FBTztZQUNUO1FBQ0YsT0FBTztZQUNMLHFDQUFxQztZQUNyQ0MsUUFBUUUsR0FBRyxDQUFDO1lBQ1pOLFFBQVE7UUFDVjtRQUVBLE1BQU1PLFVBQVU7WUFDZCxnQkFBZ0I7WUFDaEIsaUJBQWlCLFVBQWdCLE9BQU5QO1FBQzdCO1FBRUEsTUFBTVEsV0FBVyxNQUFNQyxNQUFNLEdBQTRDVixPQUF6Q04sU0FBUSxtQ0FBeUMsT0FBUk0sVUFBVztZQUNsRlcsUUFBUTtZQUNSSDtRQUNGO1FBRUEsSUFBSSxDQUFDQyxTQUFTRyxFQUFFLEVBQUU7WUFDaEIsTUFBTUMsWUFBWSxNQUFNSixTQUFTSyxJQUFJO1lBQ3JDVCxRQUFRQyxLQUFLLENBQUUsaUNBQWdDO2dCQUM3Q1MsUUFBUU4sU0FBU00sTUFBTTtnQkFDdkJDLFlBQVlQLFNBQVNPLFVBQVU7Z0JBQy9CQyxNQUFNSjtZQUNSO1lBQ0EsTUFBTSxJQUFJSyxNQUFNLFNBQTZCTCxPQUFwQkosU0FBU00sTUFBTSxFQUFDLE1BQWMsT0FBVkY7UUFDL0M7UUFFQSxNQUFNTSxPQUFPLE1BQU1WLFNBQVNXLElBQUk7UUFDaEMsT0FBT0Q7SUFDVCxFQUFFLE9B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LE9BQVY0RixXQUFVLFlBQ3hDO2dCQUFFdkU7WUFBTyxHQUNUO2dCQUFFUDtZQUFRO1lBR1osT0FBT0MsU0FBU1UsSUFBSTtRQUN0QixFQUFFLE9BQU9iLE9BQU87WUFDZEQsUUFBUUMsS0FBSyxDQUFDLDBCQUFvQyxPQUFWZ0YsV0FBVSxhQUFXaEY7WUFDN0QsTUFBTUEsT0FBTyxnREFBZ0Q7UUFDL0Q7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zZXJ2aWNlcy90dXRvci1kYXNoYm9hcmQuc2VydmljZS50cz9hZjk2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpbmV0J1xuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcblxuY29uc3QgQVBJX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMSc7XG5cbi8vIEludGVyZmFjZSBkZWZpbml0aW9ucyBmb3IgdHV0b3IgZGFzaGJvYXJkIGRhdGFcbmV4cG9ydCBpbnRlcmZhY2UgVHV0b3JTdGF0cyB7XG4gIHJhdGluZzogbnVtYmVyO1xuICByZXZpZXdzOiBudW1iZXI7XG4gIHRvdGFsRWFybmluZ3M6IG51bWJlcjtcbiAgbW9udGhseUVhcm5pbmdzOiBudW1iZXI7XG4gIHVwY29taW5nU2Vzc2lvbnM6IG51bWJlcjtcbiAgdG90YWxIb3VyczogbnVtYmVyO1xuICBjb21wbGV0ZWRTZXNzaW9uczogbnVtYmVyO1xuICBzdWJqZWN0czogc3RyaW5nW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHV0b3JpbmdTZXNzaW9uIHtcbiAgaWQ/OiBudW1iZXI7IC8vIE5ldyBwcmltYXJ5IGtleSBmcm9tIGJhY2tlbmRcbiAgc2Vzc2lvbklkPzogbnVtYmVyOyAvLyBLZWVwIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gIGNoaWxkSWQ6IG51bWJlcjtcbiAgY2hpbGROYW1lPzogc3RyaW5nO1xuICBzdWJqZWN0SWQ6IG51bWJlcjtcbiAgc3ViamVjdD86IHN0cmluZztcbiAgdGl0bGU6IHN0cmluZztcbiAgc3RhcnRUaW1lOiBzdHJpbmc7XG4gIGVuZFRpbWU6IHN0cmluZztcbiAgc3RhdHVzOiAnc2NoZWR1bGVkJyB8ICdjb25maXJtZWQnIHwgJ2NvbXBsZXRlZCcgfCAnY2FuY2VsbGVkJyB8ICdpbl9wcm9ncmVzcyc7XG4gIG5vdGVzPzogc3RyaW5nO1xuICBkdXJhdGlvbk1pbnV0ZXM/OiBudW1iZXI7XG4gIGdyYWRlTGV2ZWxOYW1lPzogc3RyaW5nOyAvLyBBZGRlZCB0byBtYXRjaCB0aGUgdXNhZ2UgaW4gdGhlIFVJXG59XG5cbi8vIENoaWxkIGFuZCBzdWJqZWN0IGluZm9ybWF0aW9uIGludGVyZmFjZXNcbi8vIFRoZXNlIGFyZSBmb3IgQVBJIHJlc3BvbnNlcyBmcm9tIHRoZSBkYXRhYmFzZVxuZXhwb3J0IGludGVyZmFjZSBDaGlsZERldGFpbHMge1xuICBjaGlsZElkOiBudW1iZXI7XG4gIGZpcnN0TmFtZTogc3RyaW5nO1xuICBsYXN0TmFtZTogc3RyaW5nO1xuICBmdWxsTmFtZTogc3RyaW5nO1xuICBncmFkZUxldmVsSWQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3ViamVjdERldGFpbHMge1xuICBzdWJqZWN0SWQ6IG51bWJlcjtcbiAgbmFtZTogc3RyaW5nO1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbn1cblxuLy8gU2FmZWx5IGNoZWNrIGlmIHdpbmRvdyBpcyBkZWZpbmVkIChjbGllbnQtc2lkZSBvbmx5KVxuY29uc3QgaXNDbGllbnQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcblxuLy8gRmV0Y2hlcyBjaGlsZCBkZXRhaWxzIGZyb20gdGhlIGJhY2tlbmQgYnkgSURcbmV4cG9ydCBjb25zdCBmZXRjaENoaWxkRGV0YWlscyA9IGFzeW5jIChjaGlsZElkOiBudW1iZXIpOiBQcm9taXNlPENoaWxkRGV0YWlscyB8IG51bGw+ID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBHZXQgdG9rZW4gZnJvbSBsb2NhbFN0b3JhZ2UgLSBvbmx5IGluIGNsaWVudCBlbnZpcm9ubWVudFxuICAgIGxldCB0b2tlbjtcbiAgICBpZiAoaXNDbGllbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FjY2Vzc1Rva2VuJyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFjY2Vzc2luZyBsb2NhbFN0b3JhZ2U6JywgZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXJ2ZXItc2lkZSBmYWxsYmFjayAoTmV4dC5qcyBTU1IpXG4gICAgICBjb25zb2xlLmxvZygnUnVubmluZyBpbiBzZXJ2ZXIgZW52aXJvbm1lbnQsIHVzaW5nIGRlZmF1bHQgdG9rZW4nKTtcbiAgICAgIHRva2VuID0gJyc7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YFxuICAgIH07XG4gICAgXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfS91c2Vycy9jaGlsZHJlbi90dXRvcmluZy9jaGlsZC8ke2NoaWxkSWR9YCwge1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIGhlYWRlcnNcbiAgICB9KTtcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBjaGlsZCBkZXRhaWxzOmAsIHtcbiAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgIGJvZHk6IGVycm9yVGV4dFxuICAgICAgfSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtlcnJvclRleHR9YCk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgY2hpbGQgZGV0YWlscyBmb3IgSUQgJHtjaGlsZElkfTpgLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8vIEZldGNoZXMgc3ViamVjdCBkZXRhaWxzIGZyb20gdGhlIGJhY2tlbmQgYnkgSURcbmV4cG9ydCBjb25zdCBmZXRjaFN1YmplY3REZXRhaWxzID0gYXN5bmMgKHN1YmplY3RJZDogbnVtYmVyKTogUHJvbWlzZTxTdWJqZWN0RGV0YWlscyB8IG51bGw+ID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBHZXQgdG9rZW4gZnJvbSBsb2NhbFN0b3JhZ2UgLSBvbmx5IGluIGNsaWVudCBlbnZpcm9ubWVudFxuICAgIGxldCB0b2tlbjtcbiAgICBpZiAoaXNDbGllbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FjY2Vzc1Rva2VuJyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFjY2Vzc2luZyBsb2NhbFN0b3JhZ2U6JywgZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXJ2ZXItc2lkZSBmYWxsYmFjayAoTmV4dC5qcyBTU1IpXG4gICAgICBjb25zb2xlLmxvZygnUnVubmluZyBpbiBzZXJ2ZXIgZW52aXJvbm1lbnQsIHVzaW5nIGRlZmF1bHQgdG9rZW4nKTtcbiAgICAgIHRva2VuID0gJyc7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YFxuICAgIH07XG4gICAgXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfS9zdWJqZWN0QW5kR3JhZGUvc3ViamVjdHMvJHtzdWJqZWN0SWR9YCwge1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIGhlYWRlcnNcbiAgICB9KTtcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBzdWJqZWN0IGRldGFpbHM6YCwge1xuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgYm9keTogZXJyb3JUZXh0XG4gICAgICB9KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgJHtyZXNwb25zZS5zdGF0dXN9OiAke2Vycm9yVGV4dH1gKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBzdWJqZWN0IGRldGFpbHMgZm9yIElEICR7c3ViamVjdElkfTpgLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBc3NpZ25tZW50IHtcbiAgYXNzaWdubWVudElkOiBudW1iZXI7XG4gIGNoaWxkSWQ6IG51bWJlcjtcbiAgY2hpbGROYW1lPzogc3RyaW5nO1xuICB0aXRsZTogc3RyaW5nO1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICBkdWVEYXRlOiBzdHJpbmc7XG4gIHN0YXR1czogJ3BlbmRpbmcnIHwgJ3N1Ym1pdHRlZCcgfCAnZ3JhZGVkJyB8ICdsYXRlJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGZWVkYmFjayB7XG4gIGZlZWRiYWNrSWQ6IG51bWJlcjtcbiAgY2hpbGRJZDogbnVtYmVyO1xuICBjaGlsZE5hbWU/OiBzdHJpbmc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIGNvbnRlbnQ6IHN0cmluZztcbiAgZmVlZGJhY2tUeXBlOiBzdHJpbmc7XG4gIGNyZWF0ZWRBdDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0dWRlbnQge1xuICBjaGlsZElkOiBudW1iZXI7XG4gIGZpcnN0TmFtZTogc3RyaW5nO1xuICBsYXN0TmFtZTogc3RyaW5nO1xuICB1c2VybmFtZTogc3RyaW5nO1xuICBwaG90bzogc3RyaW5nIHwgbnVsbDtcbiAgZ3JhZGVMZXZlbElkOiBudW1iZXIgfCBudWxsO1xuICBncmFkZUxldmVsTmFtZTogc3RyaW5nO1xuICBzdWJqZWN0czogc3RyaW5nW107XG59XG5cbi8qKlxuICogVHV0b3JEYXNoYm9hcmRTZXJ2aWNlXG4gKiBIYW5kbGVzIEFQSSBjYWxscyByZWxhdGVkIHRvIHRoZSB0dXRvciBkYXNoYm9hcmRcbiAqL1xuZXhwb3J0IGNsYXNzIFR1dG9yRGFzaGJvYXJkU2VydmljZSB7XG4gIC8qKlxuICAgKiBHZXQgYXV0aGVudGljYXRpb24gaGVhZGVyc1xuICAgKiBAcmV0dXJucyBIZWFkZXJzIG9iamVjdCB3aXRoIEF1dGhvcml6YXRpb24gdG9rZW5cbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGdldEF1dGhIZWFkZXJzKCk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4ge1xuICAgIC8vIFRyeSBtdWx0aXBsZSBwb3NzaWJsZSB0b2tlbiBrZXlzIHRvIGhhbmRsZSBpbmNvbnNpc3RlbmNpZXNcbiAgICBsZXQgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9rZW4nKSB8fCBcbiAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhY2Nlc3NUb2tlbicpIHx8IFxuICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnYWNjZXNzVG9rZW4nKTtcbiAgICBcbiAgICAvLyBGaXJzdCwgY2hlY2sgZm9yIGV4aXN0aW5nIHRva2VuIHdpdGggQmVhcmVyIHByZWZpeCAoaW1wb3J0YW50ISkgICAgXG4gICAgaWYgKHRva2VuICYmIHRva2VuLnN0YXJ0c1dpdGgoJ0JlYXJlciAnKSkge1xuICAgICAgLy8gVG9rZW4gYWxyZWFkeSBoYXMgQmVhcmVyIHByZWZpeCAtIGxlYXZlIGFzIGlzXG4gICAgICBjb25zb2xlLmxvZygnVG9rZW4gYWxyZWFkeSBoYXMgQmVhcmVyIHByZWZpeCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDaGVjayBpZiB0b2tlbiBleGlzdHMgYW5kIGlzIG5vdCBtYWxmb3JtZWRcbiAgICAgIGlmICghdG9rZW4gfHwgdG9rZW4gPT09ICd1bmRlZmluZWQnIHx8IHRva2VuID09PSAnbnVsbCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQXV0aCB0b2tlbiBpcyBtaXNzaW5nIG9yIGludmFsaWQnKTtcbiAgICAgICAgLy8gRm9yIG5vdywgZmFsbGJhY2sgdG8gZW1wdHkgdG9rZW4gdG8gbWFrZSB0aGUgZXJyb3IgbW9yZSBvYnZpb3VzIGluIEFQSSByZXNwb25zZXNcbiAgICAgICAgdG9rZW4gPSAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVuc3VyZSB0b2tlbiBpcyBwcm9wZXJseSB0cmltbWVkIHRvIGF2b2lkIHdoaXRlc3BhY2UgaXNzdWVzXG4gICAgICAgIHRva2VuID0gdG9rZW4udHJpbSgpO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RvcmUgb3JpZ2luYWwgZm9ybSBmb3IgZGlhZ25vc3RpY3NcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxUb2tlbkxlbmd0aCA9IHRva2VuLmxlbmd0aDtcbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCBCZWFyZXIgcHJlZml4IG9ubHkgaWYgaXQncyBub3QgYWxyZWFkeSB0aGVyZVxuICAgICAgICBpZiAoIXRva2VuLnN0YXJ0c1dpdGgoJ0JlYXJlciAnKSkge1xuICAgICAgICAgIHRva2VuID0gYEJlYXJlciAke3Rva2VufWA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBQcm9jZXNzZWQgdG9rZW46IG9yaWdpbmFsIGxlbmd0aD0ke29yaWdpbmFsVG9rZW5MZW5ndGh9LCBuZXcgbGVuZ3RoPSR7dG9rZW4ubGVuZ3RofWApO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBSZXR1cm4gaGVhZGVycyB3aXRoIEF1dGhvcml6YXRpb24gaWYgdG9rZW4gZXhpc3RzXG4gICAgcmV0dXJuIHtcbiAgICAgIEF1dGhvcml6YXRpb246IHRva2VuLCAvLyBEb24ndCBhZGQgQmVhcmVyIHByZWZpeCBhZ2FpbiAtIGl0IHNob3VsZCBhbHJlYWR5IGJlIGluIHRoZSB0b2tlblxuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHR1dG9yIHN0YXRzIGZvciBkYXNoYm9hcmRcbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHR1dG9yIHN0YXRzXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZ2V0VHV0b3JTdGF0cygpOiBQcm9taXNlPFR1dG9yU3RhdHM+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuZ2V0QXV0aEhlYWRlcnMoKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KFxuICAgICAgICBgJHtBUElfVVJMfS91c2Vycy90dXRvcnMvZGFzaGJvYXJkL3N0YXRzYCxcbiAgICAgICAgeyBoZWFkZXJzIH1cbiAgICAgICk7XG4gICAgICBcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB0dXRvciBzdGF0czonLCBlcnJvcik7XG4gICAgICAvLyBSZXR1cm4gZGVmYXVsdCBzdGF0cyBpZiBBUEkgZmFpbHNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJhdGluZzogMCxcbiAgICAgICAgcmV2aWV3czogMCxcbiAgICAgICAgdG90YWxFYXJuaW5nczogMCxcbiAgICAgICAgbW9udGhseUVhcm5pbmdzOiAwLFxuICAgICAgICB1cGNvbWluZ1Nlc3Npb25zOiAwLFxuICAgICAgICB0b3RhbEhvdXJzOiAwLFxuICAgICAgICBjb21wbGV0ZWRTZXNzaW9uczogMCxcbiAgICAgICAgc3ViamVjdHM6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdXBjb21pbmcgc2Vzc2lvbnMgZm9yIHRoZSB0dXRvclxuICAgKiBAcGFyYW0gbGltaXQgTnVtYmVyIG9mIHNlc3Npb25zIHRvIHJldHVyblxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggc2Vzc2lvbnMgZGF0YVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGdldFVwY29taW5nU2Vzc2lvbnMobGltaXQgPSA1KTogUHJvbWlzZTxUdXRvcmluZ1Nlc3Npb25bXT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5nZXRBdXRoSGVhZGVycygpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoXG4gICAgICAgIGAke0FQSV9VUkx9L3R1dG9ycy9zZXNzaW9ucy9teS1zZXNzaW9uc2AsXG4gICAgICAgIHsgaGVhZGVycyB9XG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBGaWx0ZXIgdGhlIHNlc3Npb25zIGJ5IHN0YXR1cyBhbmQgbGltaXQgdGhlIHJlc3VsdHMgb24gdGhlIGNsaWVudCBzaWRlXG4gICAgICBjb25zdCB1cGNvbWluZ1Nlc3Npb25zID0gcmVzcG9uc2UuZGF0YVxuICAgICAgICAuZmlsdGVyKChzZXNzaW9uOiBUdXRvcmluZ1Nlc3Npb24pID0+IFsnc2NoZWR1bGVkJywgJ2NvbmZpcm1lZCddLmluY2x1ZGVzKHNlc3Npb24uc3RhdHVzKSlcbiAgICAgICAgLnNvcnQoKGE6IFR1dG9yaW5nU2Vzc2lvbiwgYjogVHV0b3JpbmdTZXNzaW9uKSA9PiBuZXcgRGF0ZShhLnN0YXJ0VGltZSkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYi5zdGFydFRpbWUpLmdldFRpbWUoKSlcbiAgICAgICAgLnNsaWNlKDAsIGxpbWl0KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHVwY29taW5nU2Vzc2lvbnM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHVwY29taW5nIHNlc3Npb25zOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHJlY2VudCBmZWVkYmFjayBwcm92aWRlZCBieSB0aGUgdHV0b3JcbiAgICogQHBhcmFtIGxpbWl0IE51bWJlciBvZiBmZWVkYmFjayBpdGVtcyB0byByZXR1cm5cbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIGZlZWRiYWNrIGRhdGFcbiAgICovXG4gIHN0YXRpYyBhc3luYyBnZXRSZWNlbnRGZWVkYmFjayhsaW1pdCA9IDUpOiBQcm9taXNlPEZlZWRiYWNrW10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuZ2V0QXV0aEhlYWRlcnMoKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KFxuICAgICAgICBgJHtBUElfVVJMfS90dXRvcnMvZmVlZGJhY2svbXktZmVlZGJhY2tgLFxuICAgICAgICB7IGhlYWRlcnMgfVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gUHJvY2VzcyBhbmQgbGltaXQgdGhlIGZlZWRiYWNrIGRhdGEgb24gdGhlIGNsaWVudCBzaWRlXG4gICAgICBjb25zdCByZWNlbnRGZWVkYmFjayA9IHJlc3BvbnNlLmRhdGFcbiAgICAgICAgLnNvcnQoKGE6IEZlZWRiYWNrLCBiOiBGZWVkYmFjaykgPT4gbmV3IERhdGUoYi5jcmVhdGVkQXQpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGEuY3JlYXRlZEF0KS5nZXRUaW1lKCkpXG4gICAgICAgIC5zbGljZSgwLCBsaW1pdCk7XG4gICAgICBcbiAgICAgIHJldHVybiByZWNlbnRGZWVkYmFjaztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcmVjZW50IGZlZWRiYWNrOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFzc2lnbm1lbnRzIGNyZWF0ZWQgYnkgdGhlIHR1dG9yXG4gICAqIEBwYXJhbSBsaW1pdCBOdW1iZXIgb2YgYXNzaWdubWVudHMgdG8gcmV0dXJuXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBhc3NpZ25tZW50cyBkYXRhXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZ2V0UmVjZW50QXNzaWdubWVudHMobGltaXQgPSA1KTogUHJvbWlzZTxBc3NpZ25tZW50W10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuZ2V0QXV0aEhlYWRlcnMoKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KFxuICAgICAgICBgJHtBUElfVVJMfS90dXRvcnMvYXNzaWdubWVudHMvbXktYXNzaWdubWVudHNgLFxuICAgICAgICB7IGhlYWRlcnMgfVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gUHJvY2VzcyBhbmQgbGltaXQgdGhlIGFzc2lnbm1lbnRzIGRhdGEgb24gdGhlIGNsaWVudCBzaWRlXG4gICAgICAvLyBTb3J0IGJ5IGR1ZSBkYXRlIHdpdGggY2xvc2VzdCBkdWUgZGF0ZXMgZmlyc3RcbiAgICAgIGNvbnN0IHJlY2VudEFzc2lnbm1lbnRzID0gcmVzcG9uc2UuZGF0YVxuICAgICAgICAuc29ydCgoYTogQXNzaWdubWVudCwgYjogQXNzaWdubWVudCkgPT4gbmV3IERhdGUoYS5kdWVEYXRlKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShiLmR1ZURhdGUpLmdldFRpbWUoKSlcbiAgICAgICAgLnNsaWNlKDAsIGxpbWl0KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlY2VudEFzc2lnbm1lbnRzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyByZWNlbnQgYXNzaWdubWVudHM6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYXZhaWxhYmxlIHN0dWRlbnRzIGZvciB0dXRvcmluZyBzZXNzaW9uc1xuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggYXZhaWxhYmxlIHN0dWRlbnRzIGRhdGFcbiAgICovXG4gIHN0YXRpYyBhc3luYyBnZXRBdmFpbGFibGVTdHVkZW50cygpOiBQcm9taXNlPFN0dWRlbnRbXT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5nZXRBdXRoSGVhZGVycygpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoXG4gICAgICAgIGAke0FQSV9VUkx9L3VzZXJzL2NoaWxkcmVuL3R1dG9yaW5nL2F2YWlsYWJsZS1zdHVkZW50c2AsXG4gICAgICAgIHsgaGVhZGVycyB9XG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBSZXR1cm4gdGhlIHN0dWRlbnRzIGRhdGEgZGlyZWN0bHkgZnJvbSB0aGUgQVBJXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YSB8fCBbXTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgYXZhaWxhYmxlIHN0dWRlbnRzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHR1dG9yaW5nIHNlc3Npb25cbiAgICogQHBhcmFtIHNlc3Npb25EYXRhIFRoZSBkYXRhIGZvciB0aGUgbmV3IHR1dG9yaW5nIHNlc3Npb25cbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHRoZSBjcmVhdGVkIHNlc3Npb24gZGF0YVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZVNlc3Npb24oc2Vzc2lvbkRhdGE6IGFueSk6IFByb21pc2U8YW55PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmdldEF1dGhIZWFkZXJzKCk7XG4gICAgICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgc2Vzc2lvbiB3aXRoIGRhdGE6Jywgc2Vzc2lvbkRhdGEpO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLnBvc3QoXG4gICAgICAgIGAke0FQSV9VUkx9L3R1dG9ycy9zZXNzaW9uc2AsXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5zZXNzaW9uRGF0YSxcbiAgICAgICAgICBjaGlsZElkOiBOdW1iZXIoc2Vzc2lvbkRhdGEuY2hpbGRJZCksXG4gICAgICAgICAgc3ViamVjdElkOiBOdW1iZXIoc2Vzc2lvbkRhdGEuc3ViamVjdElkKVxuICAgICAgICB9LFxuICAgICAgICB7IGhlYWRlcnMgfVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ1Nlc3Npb24gY3JlYXRlZCBzdWNjZXNzZnVsbHk6JywgcmVzcG9uc2UuZGF0YSk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBzZXNzaW9uOicsIGVycm9yKTtcbiAgICAgIGlmIChlcnJvci5yZXNwb25zZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXNwb25zZSBkYXRhOicsIGVycm9yLnJlc3BvbnNlLmRhdGEpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXNwb25zZSBzdGF0dXM6JywgZXJyb3IucmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY29tcGxldGVkIHNlc3Npb25zIGZvciB0aGUgdHV0b3JcbiAgICogQHBhcmFtIGxpbWl0IE51bWJlciBvZiBzZXNzaW9ucyB0byByZXR1cm5cbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHNlc3Npb25zIGRhdGFcbiAgICovXG4gIHN0YXRpYyBhc3luYyBnZXRDb21wbGV0ZWRTZXNzaW9ucyhsaW1pdCA9IDUpOiBQcm9taXNlPFR1dG9yaW5nU2Vzc2lvbltdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmdldEF1dGhIZWFkZXJzKCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChcbiAgICAgICAgYCR7QVBJX1VSTH0vdHV0b3JzL3Nlc3Npb25zL215LXNlc3Npb25zYCxcbiAgICAgICAgeyBoZWFkZXJzIH1cbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIEZpbHRlciB0byBvbmx5IGluY2x1ZGUgY29tcGxldGVkIHNlc3Npb25zIGFuZCBzb3J0IGJ5IG1vc3QgcmVjZW50IGZpcnN0XG4gICAgICBjb25zdCBjb21wbGV0ZWRTZXNzaW9ucyA9IHJlc3BvbnNlLmRhdGFcbiAgICAgICAgLmZpbHRlcigoc2Vzc2lvbjogVHV0b3JpbmdTZXNzaW9uKSA9PiBzZXNzaW9uLnN0YXR1cyA9PT0gJ2NvbXBsZXRlZCcpXG4gICAgICAgIC5zb3J0KChhOiBUdXRvcmluZ1Nlc3Npb24sIGI6IFR1dG9yaW5nU2Vzc2lvbikgPT4gbmV3IERhdGUoYi5lbmRUaW1lKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShhLmVuZFRpbWUpLmdldFRpbWUoKSlcbiAgICAgICAgLnNsaWNlKDAsIGxpbWl0KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGNvbXBsZXRlZFNlc3Npb25zO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBjb21wbGV0ZWQgc2Vzc2lvbnM6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdHV0b3Igc3RhdGlzdGljcyBiYXNlZCBvbiBhbGwgYXZhaWxhYmxlIGRhdGFcbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIGNhbGN1bGF0ZWQgc3RhdGlzdGljc1xuICAgKi9cbiAgc3RhdGljIGFzeW5jIGNhbGN1bGF0ZVR1dG9yU3RhdHMoKTogUHJvbWlzZTxUdXRvclN0YXRzPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBhbGwgc2Vzc2lvbnMgdG8gY2FsY3VsYXRlIHN0YXRzXG4gICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5nZXRBdXRoSGVhZGVycygpO1xuICAgICAgY29uc3Qgc2Vzc2lvbnNSZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChgJHtBUElfVVJMfS90dXRvcnMvc2Vzc2lvbnMvbXktc2Vzc2lvbnNgLCB7IGhlYWRlcnMgfSk7XG4gICAgICBjb25zdCBhbGxTZXNzaW9ucyA9IHNlc3Npb25zUmVzcG9uc2UuZGF0YSBhcyBUdXRvcmluZ1Nlc3Npb25bXTtcbiAgICAgIFxuICAgICAgLy8gR2V0IHR1dG9yJ3MgcHJvZmlsZVxuICAgICAgY29uc3QgcHJvZmlsZVJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KGAke0FQSV9VUkx9L3VzZXJzL3R1dG9ycy9wcm9maWxlL21lYCwgeyBoZWFkZXJzIH0pO1xuICAgICAgY29uc3QgcHJvZmlsZSA9IHByb2ZpbGVSZXNwb25zZS5kYXRhO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgc3RhdHMgZnJvbSBzZXNzaW9ucyBkYXRhXG4gICAgICBjb25zdCBjb21wbGV0ZWRTZXNzaW9ucyA9IGFsbFNlc3Npb25zLmZpbHRlcihzZXNzaW9uID0+IHNlc3Npb24uc3RhdHVzID09PSAnY29tcGxldGVkJyk7XG4gICAgICBjb25zdCB1cGNvbWluZ1Nlc3Npb25zID0gYWxsU2Vzc2lvbnMuZmlsdGVyKHNlc3Npb24gPT4gWydzY2hlZHVsZWQnLCAnY29uZmlybWVkJ10uaW5jbHVkZXMoc2Vzc2lvbi5zdGF0dXMpKTtcbiAgICAgIGNvbnN0IHRvdGFsSG91cnMgPSBjb21wbGV0ZWRTZXNzaW9ucy5yZWR1Y2UoKHRvdGFsLCBzZXNzaW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gbmV3IERhdGUoc2Vzc2lvbi5zdGFydFRpbWUpLmdldFRpbWUoKTtcbiAgICAgICAgY29uc3QgZW5kID0gbmV3IERhdGUoc2Vzc2lvbi5lbmRUaW1lKS5nZXRUaW1lKCk7XG4gICAgICAgIGNvbnN0IGhvdXJzID0gKGVuZCAtIHN0YXJ0KSAvICgxMDAwICogNjAgKiA2MCk7IC8vIENvbnZlcnQgbWlsbGlzZWNvbmRzIHRvIGhvdXJzXG4gICAgICAgIHJldHVybiB0b3RhbCArIGhvdXJzO1xuICAgICAgfSwgMCk7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBtb250aGx5IGVhcm5pbmdzIChhc3N1bWluZyBzZXNzaW9ucyBoYXZlIGEgcHJpY2UgZmllbGQgb3IgdXNpbmcgYSBkZWZhdWx0IHJhdGUpXG4gICAgICBjb25zdCBjdXJyZW50TW9udGggPSBuZXcgRGF0ZSgpLmdldE1vbnRoKCk7XG4gICAgICBjb25zdCBjdXJyZW50WWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcbiAgICAgIGNvbnN0IHRoaXNNb250aENvbXBsZXRlZFNlc3Npb25zID0gY29tcGxldGVkU2Vzc2lvbnMuZmlsdGVyKHNlc3Npb24gPT4ge1xuICAgICAgICBjb25zdCBzZXNzaW9uRGF0ZSA9IG5ldyBEYXRlKHNlc3Npb24uZW5kVGltZSk7XG4gICAgICAgIHJldHVybiBzZXNzaW9uRGF0ZS5nZXRNb250aCgpID09PSBjdXJyZW50TW9udGggJiYgc2Vzc2lvbkRhdGUuZ2V0RnVsbFllYXIoKSA9PT0gY3VycmVudFllYXI7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gQXNzdW1pbmcgYW4gYXZlcmFnZSByYXRlIG9mICQ0MC9ob3VyIGZvciBjYWxjdWxhdGlvblxuICAgICAgY29uc3QgaG91cmx5UmF0ZSA9IDQwO1xuICAgICAgY29uc3QgbW9udGhseUVhcm5pbmdzID0gdGhpc01vbnRoQ29tcGxldGVkU2Vzc2lvbnMucmVkdWNlKCh0b3RhbCwgc2Vzc2lvbikgPT4ge1xuICAgICAgICBjb25zdCBzdGFydCA9IG5ldyBEYXRlKHNlc3Npb24uc3RhcnRUaW1lKS5nZXRUaW1lKCk7XG4gICAgICAgIGNvbnN0IGVuZCA9IG5ldyBEYXRlKHNlc3Npb24uZW5kVGltZSkuZ2V0VGltZSgpO1xuICAgICAgICBjb25zdCBob3VycyA9IChlbmQgLSBzdGFydCkgLyAoMTAwMCAqIDYwICogNjApO1xuICAgICAgICByZXR1cm4gdG90YWwgKyAoaG91cnMgKiBob3VybHlSYXRlKTtcbiAgICAgIH0sIDApO1xuICAgICAgXG4gICAgICBjb25zdCB0b3RhbEVhcm5pbmdzID0gY29tcGxldGVkU2Vzc2lvbnMucmVkdWNlKCh0b3RhbCwgc2Vzc2lvbikgPT4ge1xuICAgICAgICBjb25zdCBzdGFydCA9IG5ldyBEYXRlKHNlc3Npb24uc3RhcnRUaW1lKS5nZXRUaW1lKCk7XG4gICAgICAgIGNvbnN0IGVuZCA9IG5ldyBEYXRlKHNlc3Npb24uZW5kVGltZSkuZ2V0VGltZSgpO1xuICAgICAgICBjb25zdCBob3VycyA9IChlbmQgLSBzdGFydCkgLyAoMTAwMCAqIDYwICogNjApO1xuICAgICAgICByZXR1cm4gdG90YWwgKyAoaG91cnMgKiBob3VybHlSYXRlKTtcbiAgICAgIH0sIDApO1xuICAgICAgXG4gICAgICAvLyBSZXR1cm4gY2FsY3VsYXRlZCBzdGF0aXN0aWNzXG4gICAgICByZXR1cm4ge1xuICAgICAgICByYXRpbmc6IDQuNSwgLy8gUGxhY2Vob2xkZXIgcmF0aW5nXG4gICAgICAgIHJldmlld3M6IGNvbXBsZXRlZFNlc3Npb25zLmxlbmd0aCwgLy8gQXNzdW1pbmcgMSByZXZpZXcgcGVyIGNvbXBsZXRlZCBzZXNzaW9uXG4gICAgICAgIHRvdGFsRWFybmluZ3M6IE1hdGgucm91bmQodG90YWxFYXJuaW5ncyksXG4gICAgICAgIG1vbnRobHlFYXJuaW5nczogTWF0aC5yb3VuZChtb250aGx5RWFybmluZ3MpLFxuICAgICAgICB1cGNvbWluZ1Nlc3Npb25zOiB1cGNvbWluZ1Nlc3Npb25zLmxlbmd0aCxcbiAgICAgICAgdG90YWxIb3VyczogTWF0aC5yb3VuZCh0b3RhbEhvdXJzICogMTApIC8gMTAsIC8vIFJvdW5kIHRvIDEgZGVjaW1hbCBwbGFjZVxuICAgICAgICBjb21wbGV0ZWRTZXNzaW9uczogY29tcGxldGVkU2Vzc2lvbnMubGVuZ3RoLFxuICAgICAgICBzdWJqZWN0czogWydNYXRoJywgJ1NjaWVuY2UnLCAnRW5nbGlzaCddIC8vIFBsYWNlaG9sZGVyIHN1YmplY3RzXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjYWxjdWxhdGluZyB0dXRvciBzdGF0czonLCBlcnJvcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByYXRpbmc6IDAsXG4gICAgICAgIHJldmlld3M6IDAsXG4gICAgICAgIHRvdGFsRWFybmluZ3M6IDAsXG4gICAgICAgIG1vbnRobHlFYXJuaW5nczogMCxcbiAgICAgICAgdXBjb21pbmdTZXNzaW9uczogMCxcbiAgICAgICAgdG90YWxIb3VyczogMCxcbiAgICAgICAgY29tcGxldGVkU2Vzc2lvbnM6IDAsXG4gICAgICAgIHN1YmplY3RzOiBbXVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGF2YWlsYWJsZSBzdHVkZW50cyBmb3IgdHV0b3Jpbmcgc2Vzc2lvbnNcbiAgICogRmV0Y2hlcyB0aGUgbGlzdCBvZiBzdHVkZW50cyB0aGF0IHRoZSB0dXRvciBjYW4gY3JlYXRlIHNlc3Npb25zIHdpdGhcbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIGFycmF5IG9mIHN0dWRlbnQgZGF0YVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGdldEF2YWlsYWJsZVN0dWRlbnRzKCk6IFByb21pc2U8U3R1ZGVudFtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmdldEF1dGhIZWFkZXJzKCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChgJHtBUElfVVJMfS91c2Vycy9jaGlsZHJlbi90dXRvcmluZy9hdmFpbGFibGUtc3R1ZGVudHNgLCB7IGhlYWRlcnMgfSk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgYXZhaWxhYmxlIHN0dWRlbnRzOicsIGVycm9yKTtcbiAgICAgIC8vIFJldHVybiBlbXB0eSBhcnJheSBvbiBlcnJvclxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgYSBzZXNzaW9uJ3Mgc3RhdHVzXG4gICAqIEBwYXJhbSBzZXNzaW9uSWQgVGhlIElEIG9mIHRoZSBzZXNzaW9uIHRvIHVwZGF0ZVxuICAgKiBAcGFyYW0gc3RhdHVzIFRoZSBuZXcgc3RhdHVzIHRvIHNldFxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggdGhlIHVwZGF0ZWQgc2Vzc2lvbiBkYXRhXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgdXBkYXRlU2Vzc2lvblN0YXR1cyhzZXNzaW9uSWQ6IG51bWJlciwgc3RhdHVzOiBzdHJpbmcpOiBQcm9taXNlPFR1dG9yaW5nU2Vzc2lvbj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5nZXRBdXRoSGVhZGVycygpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5wYXRjaChcbiAgICAgICAgYCR7QVBJX1VSTH0vdHV0b3JzL3Nlc3Npb25zLyR7c2Vzc2lvbklkfS9zdGF0dXNgLFxuICAgICAgICB7IHN0YXR1cyB9LFxuICAgICAgICB7IGhlYWRlcnMgfVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHVwZGF0aW5nIHNlc3Npb24gJHtzZXNzaW9uSWR9IHN0YXR1czpgLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjsgLy8gUmV0aHJvdyB0byBsZXQgdGhlIGNvbXBvbmVudCBoYW5kbGUgdGhlIGVycm9yXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsiYXhpb3MiLCJBUElfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJpc0NsaWVudCIsImZldGNoQ2hpbGREZXRhaWxzIiwiY2hpbGRJZCIsInRva2VuIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJsb2ciLCJoZWFkZXJzIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsIm9rIiwiZXJyb3JUZXh0IiwidGV4dCIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJib2R5IiwiRXJyb3IiLCJkYXRhIiwianNvbiIsImZldGNoU3ViamVjdERldGFpbHMiLCJzdWJqZWN0SWQiLCJUdXRvckRhc2hib2FyZFNlcnZpY2UiLCJnZXRBdXRoSGVhZGVycyIsInNlc3Npb25TdG9yYWdlIiwic3RhcnRzV2l0aCIsInRyaW0iLCJvcmlnaW5hbFRva2VuTGVuZ3RoIiwibGVuZ3RoIiwiQXV0aG9yaXphdGlvbiIsImdldFR1dG9yU3RhdHMiLCJnZXQiLCJyYXRpbmciLCJyZXZpZXdzIiwidG90YWxFYXJuaW5ncyIsIm1vbnRobHlFYXJuaW5ncyIsInVwY29taW5nU2Vzc2lvbnMiLCJ0b3RhbEhvdXJzIiwiY29tcGxldGVkU2Vzc2lvbnMiLCJzdWJqZWN0cyIsImdldFVwY29taW5nU2Vzc2lvbnMiLCJsaW1pdCIsImZpbHRlciIsInNlc3Npb24iLCJpbmNsdWRlcyIsInNvcnQiLCJhIiwiYiIsIkRhdGUiLCJzdGFydFRpbWUiLCJnZXRUaW1lIiwic2xpY2UiLCJnZXRSZWNlbnRGZWVkYmFjayIsInJlY2VudEZlZWRiYWNrIiwiY3JlYXRlZEF0IiwiZ2V0UmVjZW50QXNzaWdubWVudHMiLCJyZWNlbnRBc3NpZ25tZW50cyIsImR1ZURhdGUiLCJnZXRBdmFpbGFibGVTdHVkZW50cyIsImNyZWF0ZVNlc3Npb24iLCJzZXNzaW9uRGF0YSIsInBvc3QiLCJOdW1iZXIiLCJnZXRDb21wbGV0ZWRTZXNzaW9ucyIsImVuZFRpbWUiLCJjYWxjdWxhdGVUdXRvclN0YXRzIiwic2Vzc2lvbnNSZXNwb25zZSIsImFsbFNlc3Npb25zIiwicHJvZmlsZVJlc3BvbnNlIiwicHJvZmlsZSIsInJlZHVjZSIsInRvdGFsIiwic3RhcnQiLCJlbmQiLCJob3VycyIsImN1cnJlbnRNb250aCIsImdldE1vbnRoIiwiY3VycmVudFllYXIiLCJnZXRGdWxsWWVhciIsInRoaXNNb250aENvbXBsZXRlZFNlc3Npb25zIiwic2Vzc2lvbkRhdGUiLCJob3VybHlSYXRlIiwiTWF0aCIsInJvdW5kIiwidXBkYXRlU2Vzc2lvblN0YXR1cyIsInNlc3Npb25JZCIsInBhdGNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/tutor-dashboard.service.ts\n"));

/***/ })

});