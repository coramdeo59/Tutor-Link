"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(dashboard)/tutor-dashboard/feedback/page",{

/***/ "(app-pages-browser)/./src/services/tutor-dashboard.service.ts":
/*!*************************************************!*\
  !*** ./src/services/tutor-dashboard.service.ts ***!
  \*************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TutorDashboardService: function() { return /* binding */ TutorDashboardService; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/.pnpm/axios@1.9.0/node_modules/axios/lib/axios.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.28_@babel+core@7.27.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/build/polyfills/process.js\");\n\nconst API_URL = process.env.NEXT_PUBLIC_API_URL || \"http://localhost:3001\";\n/**\n * TutorDashboardService\n * Handles API calls related to the tutor dashboard\n */ class TutorDashboardService {\n    /**\n   * Get authentication headers for API requests\n   * @returns Headers object with authorization token\n   */ static getAuthHeaders() {\n        const token = localStorage.getItem(\"accessToken\");\n        const headers = {\n            \"Content-Type\": \"application/json\"\n        };\n        if (token) {\n            headers[\"Authorization\"] = \"Bearer \".concat(token);\n        }\n        return headers;\n    }\n    /**\n   * Get tutor stats for dashboard\n   * @returns Promise with tutor stats\n   */ static async getTutorStats() {\n        try {\n            const headers = this.getAuthHeaders();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/users/tutors/dashboard/stats\"), {\n                headers\n            });\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching tutor stats:\", error);\n            // Return default stats if API fails\n            return {\n                rating: 0,\n                reviews: 0,\n                totalEarnings: 0,\n                monthlyEarnings: 0,\n                upcomingSessions: 0,\n                totalHours: 0,\n                completedSessions: 0,\n                subjects: []\n            };\n        }\n    }\n    /**\n   * Get upcoming sessions for the tutor\n   * @param limit Number of sessions to return\n   * @returns Promise with sessions data\n   */ static async getUpcomingSessions() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5;\n        try {\n            const headers = this.getAuthHeaders();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/tutors/sessions/my-sessions\"), {\n                headers\n            });\n            // Filter the sessions by status and limit the results on the client side\n            const upcomingSessions = response.data.filter((session)=>[\n                    \"scheduled\",\n                    \"confirmed\"\n                ].includes(session.status)).sort((a, b)=>new Date(a.startTime).getTime() - new Date(b.startTime).getTime()).slice(0, limit);\n            return upcomingSessions;\n        } catch (error) {\n            console.error(\"Error fetching upcoming sessions:\", error);\n            return [];\n        }\n    }\n    /**\n   * Get recent feedback provided by the tutor\n   * @param limit Number of feedback items to return\n   * @returns Promise with feedback data\n   */ static async getRecentFeedback() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5;\n        try {\n            const headers = this.getAuthHeaders();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/tutors/feedback/my-feedback\"), {\n                headers\n            });\n            // Process and limit the feedback data on the client side\n            const recentFeedback = response.data.sort((a, b)=>new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()).slice(0, limit);\n            return recentFeedback;\n        } catch (error) {\n            console.error(\"Error fetching recent feedback:\", error);\n            return [];\n        }\n    }\n    /**\n   * Get assignments created by the tutor\n   * @param limit Number of assignments to return\n   * @returns Promise with assignments data\n   */ static async getRecentAssignments() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5;\n        try {\n            const headers = this.getAuthHeaders();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/tutors/assignments/my-assignments\"), {\n                headers\n            });\n            // Process and limit the assignments data on the client side\n            // Sort by due date with closest due dates first\n            const recentAssignments = response.data.sort((a, b)=>new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime()).slice(0, limit);\n            return recentAssignments;\n        } catch (error) {\n            console.error(\"Error fetching recent assignments:\", error);\n            return [];\n        }\n    }\n    /**\n   * Get completed sessions for the tutor\n   * @param limit Number of sessions to return\n   * @returns Promise with sessions data\n   */ static async getCompletedSessions() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5;\n        try {\n            const headers = this.getAuthHeaders();\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/tutors/sessions/my-sessions\"), {\n                headers\n            });\n            // Filter to only include completed sessions and sort by most recent first\n            const completedSessions = response.data.filter((session)=>session.status === \"completed\").sort((a, b)=>new Date(b.endTime).getTime() - new Date(a.endTime).getTime()).slice(0, limit);\n            return completedSessions;\n        } catch (error) {\n            console.error(\"Error fetching completed sessions:\", error);\n            return [];\n        }\n    }\n    /**\n   * Calculate tutor statistics based on all available data\n   * @returns Promise with calculated statistics\n   */ static async calculateTutorStats() {\n        try {\n            // Get all sessions to calculate stats\n            const headers = this.getAuthHeaders();\n            const sessionsResponse = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/tutors/sessions/my-sessions\"), {\n                headers\n            });\n            const allSessions = sessionsResponse.data;\n            // Get tutor's profile\n            const profileResponse = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(API_URL, \"/users/tutors/profile/me\"), {\n                headers\n            });\n            const profile = profileResponse.data;\n            // Calculate stats from sessions data\n            const completedSessions = allSessions.filter((session)=>session.status === \"completed\");\n            const upcomingSessions = allSessions.filter((session)=>[\n                    \"scheduled\",\n                    \"confirmed\"\n                ].includes(session.status));\n            const totalHours = completedSessions.reduce((total, session)=>{\n                const start = new Date(session.startTime).getTime();\n                const end = new Date(session.endTime).getTime();\n                const hours = (end - start) / (1000 * 60 * 60); // Convert milliseconds to hours\n                return total + hours;\n            }, 0);\n            // Calculate monthly earnings (assuming sessions have a price field or using a default rate)\n            const currentMonth = new Date().getMonth();\n            const currentYear = new Date().getFullYear();\n            const thisMonthCompletedSessions = completedSessions.filter((session)=>{\n                const sessionDate = new Date(session.endTime);\n                return sessionDate.getMonth() === currentMonth && sessionDate.getFullYear() === currentYear;\n            });\n            // Assuming an average rate of $40/hour for calculation\n            const hourlyRate = 40;\n            const monthlyEarnings = thisMonthCompletedSessions.reduce((total, session)=>{\n                const start = new Date(session.startTime).getTime();\n                const end = new Date(session.endTime).getTime();\n                const hours = (end - start) / (1000 * 60 * 60);\n                return total + hours * hourlyRate;\n            }, 0);\n            const totalEarnings = completedSessions.reduce((total, session)=>{\n                const start = new Date(session.startTime).getTime();\n                const end = new Date(session.endTime).getTime();\n                const hours = (end - start) / (1000 * 60 * 60);\n                return total + hours * hourlyRate;\n            }, 0);\n            // Return calculated statistics\n            return {\n                rating: 4.5,\n                reviews: completedSessions.length,\n                totalEarnings: Math.round(totalEarnings),\n                monthlyEarnings: Math.round(monthlyEarnings),\n                upcomingSessions: upcomingSessions.length,\n                totalHours: Math.round(totalHours * 10) / 10,\n                completedSessions: completedSessions.length,\n                subjects: [\n                    \"Math\",\n                    \"Science\",\n                    \"English\"\n                ] // Placeholder subjects\n            };\n        } catch (error) {\n            console.error(\"Error calculating tutor stats:\", error);\n            return {\n                rating: 0,\n                reviews: 0,\n                totalEarnings: 0,\n                monthlyEarnings: 0,\n                upcomingSessions: 0,\n                totalHours: 0,\n                completedSessions: 0,\n                subjects: []\n            };\n        }\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy90dXRvci1kYXNoYm9hcmQuc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMEI7QUFFMUIsTUFBTUMsVUFBVUMsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxtQkFBbUIsSUFBSTtBQStDbkQ7OztDQUdDLEdBQ00sTUFBTUM7SUFDWDs7O0dBR0MsR0FDRCxPQUFlQyxpQkFBeUM7UUFDdEQsTUFBTUMsUUFBUUMsYUFBYUMsT0FBTyxDQUFDO1FBQ25DLE1BQU1DLFVBQWtDO1lBQ3RDLGdCQUFnQjtRQUNsQjtRQUVBLElBQUlILE9BQU87WUFDVEcsT0FBTyxDQUFDLGdCQUFnQixHQUFHLFVBQWdCLE9BQU5IO1FBQ3ZDO1FBRUEsT0FBT0c7SUFDVDtJQUVBOzs7R0FHQyxHQUNELGFBQWFDLGdCQUFxQztRQUNoRCxJQUFJO1lBQ0YsTUFBTUQsVUFBVSxJQUFJLENBQUNKLGNBQWM7WUFDbkMsTUFBTU0sV0FBVyxNQUFNWiw2Q0FBS0EsQ0FBQ2EsR0FBRyxDQUM5QixHQUFXLE9BQVJaLFNBQVEsa0NBQ1g7Z0JBQUVTO1lBQVE7WUFHWixPQUFPRSxTQUFTRSxJQUFJO1FBQ3RCLEVBQUUsT0FBT0MsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsK0JBQStCQTtZQUM3QyxvQ0FBb0M7WUFDcEMsT0FBTztnQkFDTEUsUUFBUTtnQkFDUkMsU0FBUztnQkFDVEMsZUFBZTtnQkFDZkMsaUJBQWlCO2dCQUNqQkMsa0JBQWtCO2dCQUNsQkMsWUFBWTtnQkFDWkMsbUJBQW1CO2dCQUNuQkMsVUFBVSxFQUFFO1lBQ2Q7UUFDRjtJQUNGO0lBRUE7Ozs7R0FJQyxHQUNELGFBQWFDLHNCQUEyRDtZQUF2Q0MsUUFBQUEsaUVBQVE7UUFDdkMsSUFBSTtZQUNGLE1BQU1oQixVQUFVLElBQUksQ0FBQ0osY0FBYztZQUNuQyxNQUFNTSxXQUFXLE1BQU1aLDZDQUFLQSxDQUFDYSxHQUFHLENBQzlCLEdBQVcsT0FBUlosU0FBUSxp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UUFBUUQsS0FBSyxDQUFDLGtDQUFrQ0E7WUFDaEQsT0FBTztnQkFDTEUsUUFBUTtnQkFDUkMsU0FBUztnQkFDVEMsZUFBZTtnQkFDZkMsaUJBQWlCO2dCQUNqQkMsa0JBQWtCO2dCQUNsQkMsWUFBWTtnQkFDWkMsbUJBQW1CO2dCQUNuQkMsVUFBVSxFQUFFO1lBQ2Q7UUFDRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3NlcnZpY2VzL3R1dG9yLWRhc2hib2FyZC5zZXJ2aWNlLnRzP2FmOTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcblxuY29uc3QgQVBJX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMSc7XG5cbi8vIEludGVyZmFjZSBkZWZpbml0aW9ucyBmb3IgdHV0b3IgZGFzaGJvYXJkIGRhdGFcbmV4cG9ydCBpbnRlcmZhY2UgVHV0b3JTdGF0cyB7XG4gIHJhdGluZzogbnVtYmVyO1xuICByZXZpZXdzOiBudW1iZXI7XG4gIHRvdGFsRWFybmluZ3M6IG51bWJlcjtcbiAgbW9udGhseUVhcm5pbmdzOiBudW1iZXI7XG4gIHVwY29taW5nU2Vzc2lvbnM6IG51bWJlcjtcbiAgdG90YWxIb3VyczogbnVtYmVyO1xuICBjb21wbGV0ZWRTZXNzaW9uczogbnVtYmVyO1xuICBzdWJqZWN0czogc3RyaW5nW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHV0b3JpbmdTZXNzaW9uIHtcbiAgc2Vzc2lvbklkOiBudW1iZXI7XG4gIGNoaWxkSWQ6IG51bWJlcjtcbiAgY2hpbGROYW1lPzogc3RyaW5nO1xuICBzdWJqZWN0SWQ6IG51bWJlcjtcbiAgc3ViamVjdD86IHN0cmluZztcbiAgdGl0bGU6IHN0cmluZztcbiAgc3RhcnRUaW1lOiBzdHJpbmc7XG4gIGVuZFRpbWU6IHN0cmluZztcbiAgc3RhdHVzOiAnc2NoZWR1bGVkJyB8ICdjb25maXJtZWQnIHwgJ2NvbXBsZXRlZCcgfCAnY2FuY2VsbGVkJyB8ICdpbl9wcm9ncmVzcyc7XG4gIG5vdGVzPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFzc2lnbm1lbnQge1xuICBhc3NpZ25tZW50SWQ6IG51bWJlcjtcbiAgY2hpbGRJZDogbnVtYmVyO1xuICBjaGlsZE5hbWU/OiBzdHJpbmc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIGR1ZURhdGU6IHN0cmluZztcbiAgc3RhdHVzOiAncGVuZGluZycgfCAnc3VibWl0dGVkJyB8ICdncmFkZWQnIHwgJ2xhdGUnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZlZWRiYWNrIHtcbiAgZmVlZGJhY2tJZDogbnVtYmVyO1xuICBjaGlsZElkOiBudW1iZXI7XG4gIGNoaWxkTmFtZT86IHN0cmluZztcbiAgdGl0bGU6IHN0cmluZztcbiAgY29udGVudDogc3RyaW5nO1xuICBmZWVkYmFja1R5cGU6IHN0cmluZztcbiAgY3JlYXRlZEF0OiBzdHJpbmc7XG59XG5cbi8qKlxuICogVHV0b3JEYXNoYm9hcmRTZXJ2aWNlXG4gKiBIYW5kbGVzIEFQSSBjYWxscyByZWxhdGVkIHRvIHRoZSB0dXRvciBkYXNoYm9hcmRcbiAqL1xuZXhwb3J0IGNsYXNzIFR1dG9yRGFzaGJvYXJkU2VydmljZSB7XG4gIC8qKlxuICAgKiBHZXQgYXV0aGVudGljYXRpb24gaGVhZGVycyBmb3IgQVBJIHJlcXVlc3RzXG4gICAqIEByZXR1cm5zIEhlYWRlcnMgb2JqZWN0IHdpdGggYXV0aG9yaXphdGlvbiB0b2tlblxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0QXV0aEhlYWRlcnMoKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYWNjZXNzVG9rZW4nKTtcbiAgICBjb25zdCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgIH07XG4gICAgXG4gICAgaWYgKHRva2VuKSB7XG4gICAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7dG9rZW59YDtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGhlYWRlcnM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHR1dG9yIHN0YXRzIGZvciBkYXNoYm9hcmRcbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHR1dG9yIHN0YXRzXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZ2V0VHV0b3JTdGF0cygpOiBQcm9taXNlPFR1dG9yU3RhdHM+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuZ2V0QXV0aEhlYWRlcnMoKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KFxuICAgICAgICBgJHtBUElfVVJMfS91c2Vycy90dXRvcnMvZGFzaGJvYXJkL3N0YXRzYCxcbiAgICAgICAgeyBoZWFkZXJzIH1cbiAgICAgICk7XG4gICAgICBcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB0dXRvciBzdGF0czonLCBlcnJvcik7XG4gICAgICAvLyBSZXR1cm4gZGVmYXVsdCBzdGF0cyBpZiBBUEkgZmFpbHNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJhdGluZzogMCxcbiAgICAgICAgcmV2aWV3czogMCxcbiAgICAgICAgdG90YWxFYXJuaW5nczogMCxcbiAgICAgICAgbW9udGhseUVhcm5pbmdzOiAwLFxuICAgICAgICB1cGNvbWluZ1Nlc3Npb25zOiAwLFxuICAgICAgICB0b3RhbEhvdXJzOiAwLFxuICAgICAgICBjb21wbGV0ZWRTZXNzaW9uczogMCxcbiAgICAgICAgc3ViamVjdHM6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdXBjb21pbmcgc2Vzc2lvbnMgZm9yIHRoZSB0dXRvclxuICAgKiBAcGFyYW0gbGltaXQgTnVtYmVyIG9mIHNlc3Npb25zIHRvIHJldHVyblxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggc2Vzc2lvbnMgZGF0YVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGdldFVwY29taW5nU2Vzc2lvbnMobGltaXQgPSA1KTogUHJvbWlzZTxUdXRvcmluZ1Nlc3Npb25bXT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5nZXRBdXRoSGVhZGVycygpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoXG4gICAgICAgIGAke0FQSV9VUkx9L3R1dG9ycy9zZXNzaW9ucy9teS1zZXNzaW9uc2AsXG4gICAgICAgIHsgaGVhZGVycyB9XG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBGaWx0ZXIgdGhlIHNlc3Npb25zIGJ5IHN0YXR1cyBhbmQgbGltaXQgdGhlIHJlc3VsdHMgb24gdGhlIGNsaWVudCBzaWRlXG4gICAgICBjb25zdCB1cGNvbWluZ1Nlc3Npb25zID0gcmVzcG9uc2UuZGF0YVxuICAgICAgICAuZmlsdGVyKChzZXNzaW9uOiBUdXRvcmluZ1Nlc3Npb24pID0+IFsnc2NoZWR1bGVkJywgJ2NvbmZpcm1lZCddLmluY2x1ZGVzKHNlc3Npb24uc3RhdHVzKSlcbiAgICAgICAgLnNvcnQoKGE6IFR1dG9yaW5nU2Vzc2lvbiwgYjogVHV0b3JpbmdTZXNzaW9uKSA9PiBuZXcgRGF0ZShhLnN0YXJ0VGltZSkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYi5zdGFydFRpbWUpLmdldFRpbWUoKSlcbiAgICAgICAgLnNsaWNlKDAsIGxpbWl0KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHVwY29taW5nU2Vzc2lvbnM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHVwY29taW5nIHNlc3Npb25zOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHJlY2VudCBmZWVkYmFjayBwcm92aWRlZCBieSB0aGUgdHV0b3JcbiAgICogQHBhcmFtIGxpbWl0IE51bWJlciBvZiBmZWVkYmFjayBpdGVtcyB0byByZXR1cm5cbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIGZlZWRiYWNrIGRhdGFcbiAgICovXG4gIHN0YXRpYyBhc3luYyBnZXRSZWNlbnRGZWVkYmFjayhsaW1pdCA9IDUpOiBQcm9taXNlPEZlZWRiYWNrW10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuZ2V0QXV0aEhlYWRlcnMoKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KFxuICAgICAgICBgJHtBUElfVVJMfS90dXRvcnMvZmVlZGJhY2svbXktZmVlZGJhY2tgLFxuICAgICAgICB7IGhlYWRlcnMgfVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gUHJvY2VzcyBhbmQgbGltaXQgdGhlIGZlZWRiYWNrIGRhdGEgb24gdGhlIGNsaWVudCBzaWRlXG4gICAgICBjb25zdCByZWNlbnRGZWVkYmFjayA9IHJlc3BvbnNlLmRhdGFcbiAgICAgICAgLnNvcnQoKGE6IEZlZWRiYWNrLCBiOiBGZWVkYmFjaykgPT4gbmV3IERhdGUoYi5jcmVhdGVkQXQpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGEuY3JlYXRlZEF0KS5nZXRUaW1lKCkpXG4gICAgICAgIC5zbGljZSgwLCBsaW1pdCk7XG4gICAgICBcbiAgICAgIHJldHVybiByZWNlbnRGZWVkYmFjaztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcmVjZW50IGZlZWRiYWNrOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFzc2lnbm1lbnRzIGNyZWF0ZWQgYnkgdGhlIHR1dG9yXG4gICAqIEBwYXJhbSBsaW1pdCBOdW1iZXIgb2YgYXNzaWdubWVudHMgdG8gcmV0dXJuXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBhc3NpZ25tZW50cyBkYXRhXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZ2V0UmVjZW50QXNzaWdubWVudHMobGltaXQgPSA1KTogUHJvbWlzZTxBc3NpZ25tZW50W10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuZ2V0QXV0aEhlYWRlcnMoKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KFxuICAgICAgICBgJHtBUElfVVJMfS90dXRvcnMvYXNzaWdubWVudHMvbXktYXNzaWdubWVudHNgLFxuICAgICAgICB7IGhlYWRlcnMgfVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gUHJvY2VzcyBhbmQgbGltaXQgdGhlIGFzc2lnbm1lbnRzIGRhdGEgb24gdGhlIGNsaWVudCBzaWRlXG4gICAgICAvLyBTb3J0IGJ5IGR1ZSBkYXRlIHdpdGggY2xvc2VzdCBkdWUgZGF0ZXMgZmlyc3RcbiAgICAgIGNvbnN0IHJlY2VudEFzc2lnbm1lbnRzID0gcmVzcG9uc2UuZGF0YVxuICAgICAgICAuc29ydCgoYTogQXNzaWdubWVudCwgYjogQXNzaWdubWVudCkgPT4gbmV3IERhdGUoYS5kdWVEYXRlKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShiLmR1ZURhdGUpLmdldFRpbWUoKSlcbiAgICAgICAgLnNsaWNlKDAsIGxpbWl0KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlY2VudEFzc2lnbm1lbnRzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyByZWNlbnQgYXNzaWdubWVudHM6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY29tcGxldGVkIHNlc3Npb25zIGZvciB0aGUgdHV0b3JcbiAgICogQHBhcmFtIGxpbWl0IE51bWJlciBvZiBzZXNzaW9ucyB0byByZXR1cm5cbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHNlc3Npb25zIGRhdGFcbiAgICovXG4gIHN0YXRpYyBhc3luYyBnZXRDb21wbGV0ZWRTZXNzaW9ucyhsaW1pdCA9IDUpOiBQcm9taXNlPFR1dG9yaW5nU2Vzc2lvbltdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmdldEF1dGhIZWFkZXJzKCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChcbiAgICAgICAgYCR7QVBJX1VSTH0vdHV0b3JzL3Nlc3Npb25zL215LXNlc3Npb25zYCxcbiAgICAgICAgeyBoZWFkZXJzIH1cbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIEZpbHRlciB0byBvbmx5IGluY2x1ZGUgY29tcGxldGVkIHNlc3Npb25zIGFuZCBzb3J0IGJ5IG1vc3QgcmVjZW50IGZpcnN0XG4gICAgICBjb25zdCBjb21wbGV0ZWRTZXNzaW9ucyA9IHJlc3BvbnNlLmRhdGFcbiAgICAgICAgLmZpbHRlcigoc2Vzc2lvbjogVHV0b3JpbmdTZXNzaW9uKSA9PiBzZXNzaW9uLnN0YXR1cyA9PT0gJ2NvbXBsZXRlZCcpXG4gICAgICAgIC5zb3J0KChhOiBUdXRvcmluZ1Nlc3Npb24sIGI6IFR1dG9yaW5nU2Vzc2lvbikgPT4gbmV3IERhdGUoYi5lbmRUaW1lKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShhLmVuZFRpbWUpLmdldFRpbWUoKSlcbiAgICAgICAgLnNsaWNlKDAsIGxpbWl0KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGNvbXBsZXRlZFNlc3Npb25zO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBjb21wbGV0ZWQgc2Vzc2lvbnM6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdHV0b3Igc3RhdGlzdGljcyBiYXNlZCBvbiBhbGwgYXZhaWxhYmxlIGRhdGFcbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIGNhbGN1bGF0ZWQgc3RhdGlzdGljc1xuICAgKi9cbiAgc3RhdGljIGFzeW5jIGNhbGN1bGF0ZVR1dG9yU3RhdHMoKTogUHJvbWlzZTxUdXRvclN0YXRzPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBhbGwgc2Vzc2lvbnMgdG8gY2FsY3VsYXRlIHN0YXRzXG4gICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5nZXRBdXRoSGVhZGVycygpO1xuICAgICAgY29uc3Qgc2Vzc2lvbnNSZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChgJHtBUElfVVJMfS90dXRvcnMvc2Vzc2lvbnMvbXktc2Vzc2lvbnNgLCB7IGhlYWRlcnMgfSk7XG4gICAgICBjb25zdCBhbGxTZXNzaW9ucyA9IHNlc3Npb25zUmVzcG9uc2UuZGF0YSBhcyBUdXRvcmluZ1Nlc3Npb25bXTtcbiAgICAgIFxuICAgICAgLy8gR2V0IHR1dG9yJ3MgcHJvZmlsZVxuICAgICAgY29uc3QgcHJvZmlsZVJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KGAke0FQSV9VUkx9L3VzZXJzL3R1dG9ycy9wcm9maWxlL21lYCwgeyBoZWFkZXJzIH0pO1xuICAgICAgY29uc3QgcHJvZmlsZSA9IHByb2ZpbGVSZXNwb25zZS5kYXRhO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgc3RhdHMgZnJvbSBzZXNzaW9ucyBkYXRhXG4gICAgICBjb25zdCBjb21wbGV0ZWRTZXNzaW9ucyA9IGFsbFNlc3Npb25zLmZpbHRlcihzZXNzaW9uID0+IHNlc3Npb24uc3RhdHVzID09PSAnY29tcGxldGVkJyk7XG4gICAgICBjb25zdCB1cGNvbWluZ1Nlc3Npb25zID0gYWxsU2Vzc2lvbnMuZmlsdGVyKHNlc3Npb24gPT4gWydzY2hlZHVsZWQnLCAnY29uZmlybWVkJ10uaW5jbHVkZXMoc2Vzc2lvbi5zdGF0dXMpKTtcbiAgICAgIGNvbnN0IHRvdGFsSG91cnMgPSBjb21wbGV0ZWRTZXNzaW9ucy5yZWR1Y2UoKHRvdGFsLCBzZXNzaW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gbmV3IERhdGUoc2Vzc2lvbi5zdGFydFRpbWUpLmdldFRpbWUoKTtcbiAgICAgICAgY29uc3QgZW5kID0gbmV3IERhdGUoc2Vzc2lvbi5lbmRUaW1lKS5nZXRUaW1lKCk7XG4gICAgICAgIGNvbnN0IGhvdXJzID0gKGVuZCAtIHN0YXJ0KSAvICgxMDAwICogNjAgKiA2MCk7IC8vIENvbnZlcnQgbWlsbGlzZWNvbmRzIHRvIGhvdXJzXG4gICAgICAgIHJldHVybiB0b3RhbCArIGhvdXJzO1xuICAgICAgfSwgMCk7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBtb250aGx5IGVhcm5pbmdzIChhc3N1bWluZyBzZXNzaW9ucyBoYXZlIGEgcHJpY2UgZmllbGQgb3IgdXNpbmcgYSBkZWZhdWx0IHJhdGUpXG4gICAgICBjb25zdCBjdXJyZW50TW9udGggPSBuZXcgRGF0ZSgpLmdldE1vbnRoKCk7XG4gICAgICBjb25zdCBjdXJyZW50WWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcbiAgICAgIGNvbnN0IHRoaXNNb250aENvbXBsZXRlZFNlc3Npb25zID0gY29tcGxldGVkU2Vzc2lvbnMuZmlsdGVyKHNlc3Npb24gPT4ge1xuICAgICAgICBjb25zdCBzZXNzaW9uRGF0ZSA9IG5ldyBEYXRlKHNlc3Npb24uZW5kVGltZSk7XG4gICAgICAgIHJldHVybiBzZXNzaW9uRGF0ZS5nZXRNb250aCgpID09PSBjdXJyZW50TW9udGggJiYgc2Vzc2lvbkRhdGUuZ2V0RnVsbFllYXIoKSA9PT0gY3VycmVudFllYXI7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gQXNzdW1pbmcgYW4gYXZlcmFnZSByYXRlIG9mICQ0MC9ob3VyIGZvciBjYWxjdWxhdGlvblxuICAgICAgY29uc3QgaG91cmx5UmF0ZSA9IDQwO1xuICAgICAgY29uc3QgbW9udGhseUVhcm5pbmdzID0gdGhpc01vbnRoQ29tcGxldGVkU2Vzc2lvbnMucmVkdWNlKCh0b3RhbCwgc2Vzc2lvbikgPT4ge1xuICAgICAgICBjb25zdCBzdGFydCA9IG5ldyBEYXRlKHNlc3Npb24uc3RhcnRUaW1lKS5nZXRUaW1lKCk7XG4gICAgICAgIGNvbnN0IGVuZCA9IG5ldyBEYXRlKHNlc3Npb24uZW5kVGltZSkuZ2V0VGltZSgpO1xuICAgICAgICBjb25zdCBob3VycyA9IChlbmQgLSBzdGFydCkgLyAoMTAwMCAqIDYwICogNjApO1xuICAgICAgICByZXR1cm4gdG90YWwgKyAoaG91cnMgKiBob3VybHlSYXRlKTtcbiAgICAgIH0sIDApO1xuICAgICAgXG4gICAgICBjb25zdCB0b3RhbEVhcm5pbmdzID0gY29tcGxldGVkU2Vzc2lvbnMucmVkdWNlKCh0b3RhbCwgc2Vzc2lvbikgPT4ge1xuICAgICAgICBjb25zdCBzdGFydCA9IG5ldyBEYXRlKHNlc3Npb24uc3RhcnRUaW1lKS5nZXRUaW1lKCk7XG4gICAgICAgIGNvbnN0IGVuZCA9IG5ldyBEYXRlKHNlc3Npb24uZW5kVGltZSkuZ2V0VGltZSgpO1xuICAgICAgICBjb25zdCBob3VycyA9IChlbmQgLSBzdGFydCkgLyAoMTAwMCAqIDYwICogNjApO1xuICAgICAgICByZXR1cm4gdG90YWwgKyAoaG91cnMgKiBob3VybHlSYXRlKTtcbiAgICAgIH0sIDApO1xuICAgICAgXG4gICAgICAvLyBSZXR1cm4gY2FsY3VsYXRlZCBzdGF0aXN0aWNzXG4gICAgICByZXR1cm4ge1xuICAgICAgICByYXRpbmc6IDQuNSwgLy8gUGxhY2Vob2xkZXIgcmF0aW5nXG4gICAgICAgIHJldmlld3M6IGNvbXBsZXRlZFNlc3Npb25zLmxlbmd0aCwgLy8gQXNzdW1pbmcgMSByZXZpZXcgcGVyIGNvbXBsZXRlZCBzZXNzaW9uXG4gICAgICAgIHRvdGFsRWFybmluZ3M6IE1hdGgucm91bmQodG90YWxFYXJuaW5ncyksXG4gICAgICAgIG1vbnRobHlFYXJuaW5nczogTWF0aC5yb3VuZChtb250aGx5RWFybmluZ3MpLFxuICAgICAgICB1cGNvbWluZ1Nlc3Npb25zOiB1cGNvbWluZ1Nlc3Npb25zLmxlbmd0aCxcbiAgICAgICAgdG90YWxIb3VyczogTWF0aC5yb3VuZCh0b3RhbEhvdXJzICogMTApIC8gMTAsIC8vIFJvdW5kIHRvIDEgZGVjaW1hbCBwbGFjZVxuICAgICAgICBjb21wbGV0ZWRTZXNzaW9uczogY29tcGxldGVkU2Vzc2lvbnMubGVuZ3RoLFxuICAgICAgICBzdWJqZWN0czogWydNYXRoJywgJ1NjaWVuY2UnLCAnRW5nbGlzaCddIC8vIFBsYWNlaG9sZGVyIHN1YmplY3RzXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjYWxjdWxhdGluZyB0dXRvciBzdGF0czonLCBlcnJvcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByYXRpbmc6IDAsXG4gICAgICAgIHJldmlld3M6IDAsXG4gICAgICAgIHRvdGFsRWFybmluZ3M6IDAsXG4gICAgICAgIG1vbnRobHlFYXJuaW5nczogMCxcbiAgICAgICAgdXBjb21pbmdTZXNzaW9uczogMCxcbiAgICAgICAgdG90YWxIb3VyczogMCxcbiAgICAgICAgY29tcGxldGVkU2Vzc2lvbnM6IDAsXG4gICAgICAgIHN1YmplY3RzOiBbXVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJheGlvcyIsIkFQSV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsIlR1dG9yRGFzaGJvYXJkU2VydmljZSIsImdldEF1dGhIZWFkZXJzIiwidG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiaGVhZGVycyIsImdldFR1dG9yU3RhdHMiLCJyZXNwb25zZSIsImdldCIsImRhdGEiLCJlcnJvciIsImNvbnNvbGUiLCJyYXRpbmciLCJyZXZpZXdzIiwidG90YWxFYXJuaW5ncyIsIm1vbnRobHlFYXJuaW5ncyIsInVwY29taW5nU2Vzc2lvbnMiLCJ0b3RhbEhvdXJzIiwiY29tcGxldGVkU2Vzc2lvbnMiLCJzdWJqZWN0cyIsImdldFVwY29taW5nU2Vzc2lvbnMiLCJsaW1pdCIsImZpbHRlciIsInNlc3Npb24iLCJpbmNsdWRlcyIsInN0YXR1cyIsInNvcnQiLCJhIiwiYiIsIkRhdGUiLCJzdGFydFRpbWUiLCJnZXRUaW1lIiwic2xpY2UiLCJnZXRSZWNlbnRGZWVkYmFjayIsInJlY2VudEZlZWRiYWNrIiwiY3JlYXRlZEF0IiwiZ2V0UmVjZW50QXNzaWdubWVudHMiLCJyZWNlbnRBc3NpZ25tZW50cyIsImR1ZURhdGUiLCJnZXRDb21wbGV0ZWRTZXNzaW9ucyIsImVuZFRpbWUiLCJjYWxjdWxhdGVUdXRvclN0YXRzIiwic2Vzc2lvbnNSZXNwb25zZSIsImFsbFNlc3Npb25zIiwicHJvZmlsZVJlc3BvbnNlIiwicHJvZmlsZSIsInJlZHVjZSIsInRvdGFsIiwic3RhcnQiLCJlbmQiLCJob3VycyIsImN1cnJlbnRNb250aCIsImdldE1vbnRoIiwiY3VycmVudFllYXIiLCJnZXRGdWxsWWVhciIsInRoaXNNb250aENvbXBsZXRlZFNlc3Npb25zIiwic2Vzc2lvbkRhdGUiLCJob3VybHlSYXRlIiwibGVuZ3RoIiwiTWF0aCIsInJvdW5kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/tutor-dashboard.service.ts\n"));

/***/ })

});